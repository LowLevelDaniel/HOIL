/**
 * @file test_parser.c
 * @brief Test for the HOIL parser
 * 
 * This file contains tests for the parser to ensure it correctly
 * builds an AST from HOIL source code.
 *
 * @author Generated by Claude
 * @date 2025-03-13
 */

#include "lexer.h"
#include "parser.h"
#include "ast.h"
#include "error_handling.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <assert.h>

/**
 * @brief Test structure for parser tests
 */
typedef struct {
  const char* input;      /**< Input HOIL code */
  bool should_pass;       /**< Whether parsing should succeed */
  const char* description; /**< Test description */
} parser_test_t;

/**
 * @brief Verify module structure after parsing
 * 
 * @param module Parsed module
 * @param test_index Test index for reporting
 * @return true if verification passed, false otherwise
 */
static bool verify_module(ast_module_t* module, int test_index) {
  if (module == NULL) {
    printf("  Failed: Module is NULL\n");
    return false;
  }
  
  // Basic verification
  if (module->name == NULL) {
    printf("  Failed: Module name is NULL\n");
    return false;
  }
  
  printf("  Module name: %s\n", module->name);
  printf("  Types: %u\n", module->type_count);
  printf("  Constants: %u\n", module->constant_count);
  printf("  Globals: %u\n", module->global_count);
  printf("  Functions: %u\n", module->function_count);
  
  // Additional verification based on test index could be added here
  
  return true;
}

/**
 * @brief Main test function
 * 
 * @return 0 on success, non-zero on failure
 */
int main() {
  // Initialize error handling
  error_init(true, true);
  
  // Define test cases
  parser_test_t tests[] = {
    {
      "MODULE \"test\";\n",
      true,
      "Simple module declaration"
    },
    {
      "MODULE \"test\";\n"
      "TYPE point { x: f32; y: f32; }\n",
      true,
      "Module with type definition"
    },
    {
      "MODULE \"test\";\n"
      "CONSTANT PI: f64 = 3.14159;\n",
      true,
      "Module with constant"
    },
    {
      "MODULE \"test\";\n"
      "FUNCTION add(a: i32, b: i32) -> i32 {\n"
      "  ENTRY:\n"
      "    result = ADD a, b;\n"
      "    RET result;\n"
      "}\n",
      true,
      "Module with function"
    },
    {
      "MODULE \"test\";\n"
      "FUNCTION missing_entry() -> void {\n"
      "}\n",
      false,
      "Function without ENTRY block (should fail)"
    },
    {
      "MODULE \"test\";\n"
      "GLOBAL counter: i32 = 0;\n"
      "FUNCTION increment() -> i32 {\n"
      "  ENTRY:\n"
      "    value = LOAD [counter];\n"
      "    new_value = ADD value, 1;\n"
      "    STORE [counter], new_value;\n"
      "    RET new_value;\n"
      "}\n",
      true,
      "Module with global and function using it"
    }
  };
  
  // Run tests
  int test_count = sizeof(tests) / sizeof(tests[0]);
  int passed = 0;
  int failed = 0;
  
  for (int i = 0; i < test_count; i++) {
    printf("Test %d: %s\n", i + 1, tests[i].description);
    
    // Create lexer and parser
    lexer_t* lexer = lexer_create(tests[i].input, strlen(tests[i].input), "test.hoil");
    assert(lexer != NULL);
    
    parser_t* parser = parser_create(lexer);
    assert(parser != NULL);
    
    // Parse module
    error_reset();  // Reset error state before each test
    ast_module_t* module = parser_parse_module(parser);
    
    // Check result
    bool has_error = error_occurred();
    bool test_passed = true;
    
    if (tests[i].should_pass) {
      if (has_error || module == NULL) {
        printf("  Failed: Expected successful parse but got error\n");
        if (error_last_message() != NULL) {
          printf("  Error: %s\n", error_last_message());
        }
        test_passed = false;
      } else {
        // Verify module structure
        test_passed = verify_module(module, i);
      }
    } else {
      if (!has_error && module != NULL) {
        printf("  Failed: Expected parse error but got success\n");
        test_passed = false;
      } else {
        printf("  Expected error occurred: %s\n", 
               error_last_message() != NULL ? error_last_message() : "unknown error");
      }
    }
    
    // Clean up
    if (module != NULL) {
      ast_module_destroy(module);
    }
    parser_destroy(parser);
    lexer_destroy(lexer);
    
    // Update counters
    if (test_passed) {
      printf("  Passed\n");
      passed++;
    } else {
      failed++;
    }
    
    printf("\n");
  }
  
  // Print summary
  printf("Tests completed: %d passed, %d failed\n", passed, failed);
  
  return failed > 0 ? 1 : 0;
}