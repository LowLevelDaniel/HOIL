; Fibonacci sequence calculator in HOIL
; Calculates the first 10 numbers of the Fibonacci sequence

; Initialize constants
VAL DEFV dint, count, id10     ; Number of Fibonacci numbers to generate
VAL DEFV dint, one, id1        ; Constant 1
VAL DEFV dint, zero, id0       ; Constant 0
VAL DEFV dint, ascii_0, id48   ; ASCII '0'
VAL DEFV dint, ten, id10       ; Constant 10
VAL DEFV int8, space, id32     ; ASCII space
VAL DEFV int8, newline, id10   ; ASCII newline

; Initialize variables
VAL DEFV dint, a, id0         ; First Fibonacci number
VAL DEFV dint, b, id1         ; Second Fibonacci number
VAL DEFV dint, temp, id0      ; Temporary variable
VAL DEFV dint, i, id0         ; Loop counter
VAL DEFV dint, digit, id0     ; Current digit for conversion

; Print header
VAL DEFV int8, msg1, id'F     ; 'F'
VAL DEFV int8, msg2, id'i     ; 'i'
VAL DEFV int8, msg3, id'b     ; 'b'
VAL DEFV int8, msg4, id'o     ; 'o'
VAL DEFV int8, msg5, id'n     ; 'n'
VAL DEFV int8, msg6, id'a     ; 'a'
VAL DEFV int8, msg7, id'c     ; 'c'
VAL DEFV int8, msg8, id'c     ; 'c'
VAL DEFV int8, msg9, id'i     ; 'i'
VAL DEFV int8, msg10, id' '   ; ' '
VAL DEFV int8, msg11, id'S'   ; 'S'
VAL DEFV int8, msg12, id'e'   ; 'e'
VAL DEFV int8, msg13, id'q'   ; 'q'
VAL DEFV int8, msg14, id'u'   ; 'u'
VAL DEFV int8, msg15, id'e'   ; 'e'
VAL DEFV int8, msg16, id'n'   ; 'n'
VAL DEFV int8, msg17, id'c'   ; 'c'
VAL DEFV int8, msg18, id'e'   ; 'e'
VAL DEFV int8, msg19, id':'   ; ':'

; Print header
CF SYSC 1, 1, &msg1, 1
CF SYSC 1, 1, &msg2, 1
CF SYSC 1, 1, &msg3, 1
CF SYSC 1, 1, &msg4, 1
CF SYSC 1, 1, &msg5, 1
CF SYSC 1, 1, &msg6, 1
CF SYSC 1, 1, &msg7, 1
CF SYSC 1, 1, &msg8, 1
CF SYSC 1, 1, &msg9, 1
CF SYSC 1, 1, &msg10, 1
CF SYSC 1, 1, &msg11, 1
CF SYSC 1, 1, &msg12, 1
CF SYSC 1, 1, &msg13, 1
CF SYSC 1, 1, &msg14, 1
CF SYSC 1, 1, &msg15, 1
CF SYSC 1, 1, &msg16, 1
CF SYSC 1, 1, &msg17, 1
CF SYSC 1, 1, &msg18, 1
CF SYSC 1, 1, &msg19, 1
CF SYSC 1, 1, &newline, 1

; Main loop
CF LABEL loop_start
  ; Check if i >= count
  MATH SUB temp, i, count
  CF JCOND GE, temp, zero, loop_end

  ; Print current Fibonacci number (a)
  VAL MOVV dint, temp, a  ; Copy a to temp for printing
  CF CALL print_number
  CF SYSC 1, 1, &space, 1

  ; Calculate next Fibonacci number
  MATH ADD temp, a, b     ; temp = a + b
  VAL MOVV dint, a, b     ; a = b
  VAL MOVV dint, b, temp  ; b = temp
  
  ; Increment counter
  MATH ADD i, i, one
  
  ; Loop back
  CF JMP loop_start

CF LABEL loop_end
CF SYSC 1, 1, &newline, 1

; Exit
CF SYSC 60, 0

; Function to print a number
CF LABEL print_number
  ; Set up for number printing
  VAL DEFV dint, print_temp, id0   ; Temporary number storage
  VAL DEFV dint, print_digit, id0  ; Current digit
  VAL DEFV dint, print_rem, id0    ; Remainder
  VAL DEFV int8, print_buf, id0    ; Output buffer
  
  VAL MOVV dint, print_temp, temp  ; Copy number to print_temp
  
  ; Handle special case for 0
  CF JCOND NE, print_temp, zero, print_convert
  VAL DEFV int8, print_buf, id'0   ; ASCII '0'
  CF SYSC 1, 1, &print_buf, 1
  CF RET
  
  CF LABEL print_convert
  ; If number is 0 and we've processed at least one digit, we're done
  CF JCOND EQ, print_temp, zero, print_end
  
  ; Calculate remainder and quotient
  MATH MOD print_rem, print_temp, ten    ; rem = number % 10
  MATH DIV print_temp, print_temp, ten   ; number = number / 10
  
  ; Push digit onto stack
  MATH ADD print_digit, print_rem, ascii_0  ; Convert to ASCII
  VAL MOVV int8, print_buf, print_digit
  CF PUSH print_buf
  
  ; Increase digit count
  MATH ADD print_digit, print_digit, one
  
  ; Continue conversion
  CF JMP print_convert
  
  CF LABEL print_end
  ; Print digits from stack
  CF LABEL print_loop
    CF JCOND EQ, print_digit, zero, print_done
    CF POP print_buf
    CF SYSC 1, 1, &print_buf, 1
    MATH SUB print_digit, print_digit, one
    CF JMP print_loop
  
  CF LABEL print_done
  CF RET