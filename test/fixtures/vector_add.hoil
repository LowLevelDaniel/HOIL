// Vector addition example in HOIL
MODULE "vector_add";

// Target specification for CPU with vector extensions
TARGET {
  device_class = "CPU"
}

// Type definitions
TYPE vector3 {
  x: f32;
  y: f32;
  z: f32;
}

// Constants
CONSTANT ZERO_VECTOR: vector3 = { 0.0, 0.0, 0.0 };
CONSTANT PI: f32 = 3.14159265359;

// Global variables
GLOBAL vector_count: i32 = 0;

// External function declarations
EXTERN FUNCTION print_vector(v: ptr<vector3>) -> void;
EXTERN FUNCTION printf(format: ptr<i8>, ...) -> i32;

// Vector addition function
FUNCTION add_vectors(a: ptr<vector3>, b: ptr<vector3>, result: ptr<vector3>) -> void {
  ENTRY:
    // Load vector components
    a_vec = LOAD [a];
    b_vec = LOAD [b];
    
    // Add vector components 
    result_x = ADD a_vec.x, b_vec.x;
    result_y = ADD a_vec.y, b_vec.y;
    result_z = ADD a_vec.z, b_vec.z;
    
    // Create result vector
    result_vec = a_vec;  // Reuse structure for output
    result_vec.x = result_x;
    result_vec.y = result_y;
    result_vec.z = result_z;
    
    // Store result
    STORE [result], result_vec;
    
    // Increment global counter
    count = LOAD [vector_count];
    new_count = ADD count, 1;
    STORE [vector_count], new_count;
    
    RET;
}

// Vector normalization function
FUNCTION normalize_vector(v: ptr<vector3>) -> bool {
  ENTRY:
    // Load vector
    vec = LOAD [v];
    
    // Calculate squared length
    x_squared = MUL vec.x, vec.x;
    y_squared = MUL vec.y, vec.y;
    z_squared = MUL vec.z, vec.z;
    
    len_squared = ADD x_squared, ADD y_squared, z_squared;
    
    // Check for zero vector
    is_zero = CMP_LT len_squared, 0.0001;
    BR is_zero, ZERO_CASE, NORMAL_CASE;
    
  ZERO_CASE:
    // Cannot normalize zero vector
    RET false;
    
  NORMAL_CASE:
    // Calculate length
    length = SQRT len_squared;
    
    // Calculate reciprocal of length
    inv_length = DIV 1.0, length;
    
    // Normalize components
    normalized_x = MUL vec.x, inv_length;
    normalized_y = MUL vec.y, inv_length;
    normalized_z = MUL vec.z, inv_length;
    
    // Update vector in place
    vec.x = normalized_x;
    vec.y = normalized_y;
    vec.z = normalized_z;
    
    // Store normalized vector
    STORE [v], vec;
    
    RET true;
}

// Dot product function
FUNCTION dot_product(a: ptr<vector3>, b: ptr<vector3>) -> f32 {
  ENTRY:
    // Load vectors
    vec_a = LOAD [a];
    vec_b = LOAD [b];
    
    // Calculate component products
    x_product = MUL vec_a.x, vec_b.x;
    y_product = MUL vec_a.y, vec_b.y;
    z_product = MUL vec_a.z, vec_b.z;
    
    // Sum products
    sum = ADD x_product, ADD y_product, z_product;
    
    RET sum;
}

// Main function
FUNCTION main() -> i32 {
  ENTRY:
    // Allocate vectors on stack
    v1 = ALLOCA vector3;
    v2 = ALLOCA vector3;
    result = ALLOCA vector3;
    
    // Initialize vectors
    v1_data = LOAD [v1];
    v1_data.x = 1.0;
    v1_data.y = 2.0;
    v1_data.z = 3.0;
    STORE [v1], v1_data;
    
    v2_data = LOAD [v2];
    v2_data.x = 4.0;
    v2_data.y = 5.0;
    v2_data.z = 6.0;
    STORE [v2], v2_data;
    
    // Add vectors
    CALL add_vectors(v1, v2, result);
    
    // Print result
    CALL print_vector(result);
    
    // Calculate dot product
    dp = CALL dot_product(v1, v2);
    
    // Print dot product
    format = LOAD_STRING "Dot product: %f\n";
    CALL printf(format, dp);
    
    // Normalize v1
    success = CALL normalize_vector(v1);
    
    // Check normalization result
    BR success, NORMALIZED, NOT_NORMALIZED;
    
  NORMALIZED:
    CALL print_vector(v1);
    BR ALWAYS, DONE;
    
  NOT_NORMALIZED:
    error_msg = LOAD_STRING "Could not normalize vector\n";
    CALL printf(error_msg);
    
  DONE:
    RET 0;
}

// Vector implementation with SIMD instructions 
FUNCTION add_vectors(a: ptr<vector3>, b: ptr<vector3>, result: ptr<vector3>) -> void
TARGET "CPU" {
  required_features = ["avx2"]
  
  ENTRY:
    // Load vectors using SIMD
    a_simd = VLOAD [a];
    b_simd = VLOAD [b];
    
    // Add vectors with single instruction
    result_simd = VADD a_simd, b_simd;
    
    // Store result
    STORE [result], result_simd;
    
    // Increment global counter
    count = LOAD [vector_count];
    new_count = ADD count, 1;
    STORE [vector_count], new_count;
    
    RET;
}