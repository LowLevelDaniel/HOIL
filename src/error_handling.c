/**
 * @file error_handling.c
 * @brief Implementation of the error handling system
 * 
 * This file implements a centralized error reporting and tracking system
 * for the HOIL to COIL compiler.
 *
 * @author Generated by Claude
 * @date 2025-03-13
 */

#include "error_handling.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

/**
 * @brief Maximum length of error message
 */
#define ERROR_MAX_MESSAGE_LENGTH 1024

/**
 * @brief Internal error handling state
 */
static struct {
  bool initialized;          /**< Whether the system is initialized */
  bool verbose;              /**< Whether to print verbose messages */
  bool debug;                /**< Whether to include debug info */
  int count;                 /**< Number of errors encountered */
  error_code_t last_code;    /**< Last encountered error code */
  char last_message[ERROR_MAX_MESSAGE_LENGTH]; /**< Last error message */
} error_state = {
  .initialized = false,
  .verbose = false,
  .debug = false,
  .count = 0,
  .last_code = ERROR_NONE,
  .last_message = {0}
};

/**
 * @brief Convert error code to string
 * 
 * @param code Error code
 * @return String representation of error code
 */
static const char* error_code_to_string(error_code_t code) {
  switch (code) {
    case ERROR_NONE: return "No error";
    case ERROR_INVALID_ARGUMENT: return "Invalid argument";
    case ERROR_MEMORY: return "Memory allocation error";
    case ERROR_IO: return "I/O error";
    case ERROR_LEXICAL: return "Lexical error";
    case ERROR_SYNTAX: return "Syntax error";
    case ERROR_SEMANTIC: return "Semantic error";
    case ERROR_CODEGEN: return "Code generation error";
    case ERROR_INTERNAL: return "Internal compiler error";
    case ERROR_SECURITY: return "Security Violation";
    default: return "Unknown error";
  }
}

/**
 * @brief Initialize the error handling system
 * 
 * @param verbose Enable verbose error messages
 * @param debug Enable additional debug information
 */
void error_init(bool verbose, bool debug) {
  error_state.initialized = true;
  error_state.verbose = verbose;
  error_state.debug = debug;
  error_state.count = 0;
  error_state.last_code = ERROR_NONE;
  error_state.last_message[0] = '\0';
}

/**
 * @brief Report an error
 * 
 * @param code Error code
 * @param format Format string (printf style)
 * @param ... Variable arguments
 */
void error_report(error_code_t code, const char* format, ...) {
  // Ensure system is initialized
  if (!error_state.initialized) {
    error_init(false, false);
  }

  // Update error state
  error_state.count++;
  error_state.last_code = code;

  // Format error message
  va_list args;
  va_start(args, format);
  
  // Create prefix with error code
  char prefix[64];
  snprintf(prefix, sizeof(prefix), "%s: ", error_code_to_string(code));
  
  // Copy prefix to message
  strncpy(error_state.last_message, prefix, ERROR_MAX_MESSAGE_LENGTH - 1);
  error_state.last_message[ERROR_MAX_MESSAGE_LENGTH - 1] = '\0';
  
  // Append formatted message
  size_t prefix_len = strlen(prefix);
  vsnprintf(error_state.last_message + prefix_len, 
           ERROR_MAX_MESSAGE_LENGTH - prefix_len, 
           format, args);
  
  va_end(args);

  // Print error message
  if (error_state.verbose) {
    fprintf(stderr, "%s\n", error_state.last_message);
    
    // Print debug backtrace if enabled
    if (error_state.debug && code == ERROR_INTERNAL) {
      fprintf(stderr, "This is an internal compiler error and should be reported.\n");
      // In a real implementation, we might print a backtrace here
    }
  } else {
    // In non-verbose mode, print a simplified message
    fprintf(stderr, "%s\n", error_state.last_message);
  }
}

/**
 * @brief Check if any errors have occurred
 * 
 * @return true if errors have occurred, false otherwise
 */
bool error_occurred(void) {
  return error_state.count > 0;
}

/**
 * @brief Get the number of errors that have occurred
 * 
 * @return Number of errors
 */
int error_count(void) {
  return error_state.count;
}

/**
 * @brief Get the last error code
 * 
 * @return Last error code
 */
error_code_t error_last_code(void) {
  return error_state.last_code;
}

/**
 * @brief Get the last error message
 * 
 * @return Last error message or NULL if no errors
 */
const char* error_last_message(void) {
  if (error_state.count == 0) {
    return NULL;
  }
  return error_state.last_message;
}

/**
 * @brief Reset error state
 */
void error_reset(void) {
  error_state.count = 0;
  error_state.last_code = ERROR_NONE;
  error_state.last_message[0] = '\0';
}