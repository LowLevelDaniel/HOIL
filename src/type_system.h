/**
 * @file type_system.h
 * @brief Type system for HOIL compiler
 * 
 * This file defines the interface for type operations, comparisons,
 * and validations used during compilation.
 *
 * @author Generated by Claude
 * @date 2025-03-13
 */

#ifndef TYPE_SYSTEM_H
#define TYPE_SYSTEM_H

#include "ast.h"
#include <stdbool.h>
#include <stddef.h>

/**
 * @brief Initialize the type system
 * 
 * @return true if successful, false otherwise
 */
bool type_system_init(void);

/**
 * @brief Clean up the type system
 */
void type_system_cleanup(void);

/**
 * @brief Check if two types are compatible (can be assigned)
 * 
 * @param dest Destination type
 * @param source Source type
 * @return true if compatible, false otherwise
 */
bool types_are_compatible(const ast_type_t* dest, const ast_type_t* source);

/**
 * @brief Check if two types are exactly equal
 * 
 * @param type1 First type
 * @param type2 Second type
 * @return true if equal, false otherwise
 */
bool types_are_equal(const ast_type_t* type1, const ast_type_t* type2);

/**
 * @brief Check if a type needs conversion to be compatible with another
 * 
 * @param dest Destination type
 * @param source Source type
 * @return true if conversion needed, false otherwise
 */
bool type_needs_conversion(const ast_type_t* dest, const ast_type_t* source);

/**
 * @brief Get the common type between two types (for binary operations)
 * 
 * @param type1 First operand type
 * @param type2 Second operand type
 * @return Common type or NULL if incompatible
 */
ast_type_t* get_common_type(const ast_type_t* type1, const ast_type_t* type2);

/**
 * @brief Get the result type of a binary operation
 * 
 * @param opcode Operation code
 * @param type1 First operand type
 * @param type2 Second operand type
 * @return Result type or NULL if operation invalid for types
 */
ast_type_t* get_binary_op_result_type(opcode_t opcode, const ast_type_t* type1, const ast_type_t* type2);

/**
 * @brief Get the result type of a unary operation
 * 
 * @param opcode Operation code
 * @param type Operand type
 * @return Result type or NULL if operation invalid for type
 */
ast_type_t* get_unary_op_result_type(opcode_t opcode, const ast_type_t* type);

/**
 * @brief Check if a type is integer (signed or unsigned)
 * 
 * @param type Type to check
 * @return true if integer, false otherwise
 */
bool type_is_integer(const ast_type_t* type);

/**
 * @brief Check if a type is a floating-point type
 * 
 * @param type Type to check
 * @return true if floating-point, false otherwise
 */
bool type_is_float(const ast_type_t* type);

/**
 * @brief Check if a type is numeric (integer or float)
 * 
 * @param type Type to check
 * @return true if numeric, false otherwise
 */
bool type_is_numeric(const ast_type_t* type);

/**
 * @brief Check if a type is a boolean
 * 
 * @param type Type to check
 * @return true if boolean, false otherwise
 */
bool type_is_boolean(const ast_type_t* type);

/**
 * @brief Check if a type is a pointer
 * 
 * @param type Type to check
 * @return true if pointer, false otherwise
 */
bool type_is_pointer(const ast_type_t* type);

/**
 * @brief Check if a type is a vector
 * 
 * @param type Type to check
 * @return true if vector, false otherwise
 */
bool type_is_vector(const ast_type_t* type);

/**
 * @brief Check if a type is an array
 * 
 * @param type Type to check
 * @return true if array, false otherwise
 */
bool type_is_array(const ast_type_t* type);

/**
 * @brief Check if a type is a structure
 * 
 * @param type Type to check
 * @return true if structure, false otherwise
 */
bool type_is_struct(const ast_type_t* type);

/**
 * @brief Check if a type is a function
 * 
 * @param type Type to check
 * @return true if function, false otherwise
 */
bool type_is_function(const ast_type_t* type);

/**
 * @brief Check if a type is void
 * 
 * @param type Type to check
 * @return true if void, false otherwise
 */
bool type_is_void(const ast_type_t* type);

/**
 * @brief Get a string representation of a type
 * 
 * @param type Type to convert
 * @return String representation (caller must free) or NULL on error
 */
char* type_to_string(const ast_type_t* type);

/**
 * @brief Validate a constant value against a type
 * 
 * @param constant Constant to validate
 * @param type Expected type
 * @return true if valid, false otherwise
 */
bool validate_constant_type(const ast_constant_t* constant, const ast_type_t* type);

/**
 * @brief Validate function parameter count and types
 * 
 * @param function Function to validate
 * @param arg_count Number of arguments
 * @param arg_types Array of argument types
 * @param error_msg Buffer to store error message (may be NULL)
 * @param error_msg_size Size of error message buffer
 * @return true if valid, false otherwise
 */
bool validate_function_call(const ast_function_t* function, uint32_t arg_count, 
                           const ast_type_t** arg_types, char* error_msg, size_t error_msg_size);

#endif /* TYPE_SYSTEM_H */