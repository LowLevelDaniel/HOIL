/**
 * @file parser.c
 * @brief Implementation of the parser for HOIL language
 * 
 * This file implements the parser that processes tokens from the lexer
 * and builds an abstract syntax tree (AST).
 *
 * @author Generated by Claude
 * @date 2025-03-13
 */

#include "parser.h"
#include "error_handling.h"
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stdarg.h>

/**
 * @brief Parser structure definition
 */
struct parser_t {
  lexer_t* lexer;               /**< Lexer to read tokens from */
  token_t current_token;        /**< Current token being processed */
  bool has_current_token;       /**< Whether current_token is valid */
  token_t previous_token;       /**< Previously consumed token */
  bool has_error;               /**< Whether an error occurred during parsing */
  symbol_table_t* symbols;      /**< Symbol table */
  
  // Current function context
  ast_function_t* current_function; /**< Function being parsed */
  ast_basic_block_t* current_block; /**< Block being parsed */
};

/**
 * @brief Advance to the next token
 * 
 * @param parser Parser instance
 * @return Current token
 */
static token_t advance(parser_t* parser) {
  if (parser->has_current_token) {
    parser->previous_token = parser->current_token;
    
    // Clear any owned resources in current_token since we've moved it to previous_token
    parser->current_token.string_value = NULL;
    parser->current_token.identifier_value = NULL;
  }
  
  parser->current_token = lexer_next_token(parser->lexer);
  parser->has_current_token = true;
  
  // Check for lexical errors
  if (parser->current_token.type == TOKEN_ERROR) {
    parser->has_error = true;
  }
  
  return parser->current_token;
}

/**
 * @brief Report a syntax error at the current token
 * 
 * @param parser Parser instance
 * @param message Error message format string
 * @param ... Additional format arguments
 */
static void syntax_error(parser_t* parser, const char* message, ...) {
  char buffer[256];
  va_list args;
  va_start(args, message);
  vsnprintf(buffer, sizeof(buffer), message, args);
  va_end(args);
  
  error_report(ERROR_SYNTAX, "%s:%zu:%zu: %s", 
               parser_filename(parser), 
               parser_line(parser), 
               parser_column(parser), 
               buffer);
  
  parser->has_error = true;
}

/**
 * @brief Peek at the current token without consuming it
 * 
 * @param parser Parser instance
 * @return Current token
 */
static token_t peek(parser_t* parser) {
  if (parser->has_current_token) {
    return parser->current_token;
  }
  
  return lexer_peek_token(parser->lexer);
}

/**
 * @brief Check if the current token is of the specified type
 * 
 * @param parser Parser instance
 * @param type Expected token type
 * @return true if the current token is of the specified type, false otherwise
 */
static bool check(parser_t* parser, token_type_t type) {
  token_t token = peek(parser);
  return token.type == type;
}

/**
 * @brief Consume the current token if it matches the expected type
 * 
 * @param parser Parser instance
 * @param type Expected token type
 * @param error_message Error message if the token doesn't match
 * @return true if the token was consumed, false if there was an error
 */
static bool consume(parser_t* parser, token_type_t type, const char* error_message) {
  if (check(parser, type)) {
    advance(parser);
    return true;
  }
  
  syntax_error(parser, "%s, got %s", error_message, token_type_to_string(peek(parser).type));
  return false;
}

/**
 * @brief Expect and consume a token of the specified type
 * 
 * Reports an error if the current token doesn't match the expected type.
 * 
 * @param parser Parser instance
 * @param type Expected token type
 * @param error_message Error message if the token doesn't match
 * @return true if the token was consumed, false if there was an error
 */
static bool expect(parser_t* parser, token_type_t type, const char* error_message) {
  if (consume(parser, type, error_message)) {
    return true;
  }
  
  // Skip the current token to try to recover
  if (!check(parser, TOKEN_EOF)) {
    advance(parser);
  }
  
  return false;
}

/**
 * @brief Extract text from a token
 * 
 * @param token Token to extract text from
 * @return Extracted text (caller must free) or NULL on error
 */
static char* token_text(const token_t* token) {
  char* text = (char*)malloc(token->length + 1);
  if (text == NULL) {
    error_report(ERROR_MEMORY, "Failed to allocate memory for token text");
    return NULL;
  }
  
  strncpy(text, token->start, token->length);
  text[token->length] = '\0';
  
  return text;
}

/**
 * @brief Create a new parser instance
 * 
 * @param lexer Lexer instance to read tokens from
 * @return Pointer to created parser or NULL on failure
 */
 parser_t* parser_create(lexer_t* lexer) {
  if (lexer == NULL) {
    error_report(ERROR_INVALID_ARGUMENT, "Lexer cannot be NULL");
    return NULL;
  }
  
  parser_t* parser = (parser_t*)malloc(sizeof(parser_t));
  if (parser == NULL) {
    error_report(ERROR_MEMORY, "Failed to allocate memory for parser");
    return NULL;
  }
  
  parser->lexer = lexer;
  parser->has_current_token = false;
  parser->has_error = false;
  
  // Create symbol table
  parser->symbols = symbol_table_create();
  if (parser->symbols == NULL) {
    error_report(ERROR_MEMORY, "Failed to create symbol table");
    free(parser);
    return NULL;
  }
  
  // Initialize function context
  parser->current_function = NULL;
  parser->current_block = NULL;
  
  // Prime the parser by reading the first token
  advance(parser);  // Add this line
  
  return parser;
}

/**
 * @brief Destroy a parser instance and free resources
 * 
 * @param parser Parser to destroy
 */
void parser_destroy(parser_t* parser) {
  if (parser == NULL) {
    return;
  }
  
  // Free token resources if needed
  if (parser->has_current_token) {
    if (parser->current_token.type == TOKEN_STRING) {
      free(parser->current_token.string_value);
    } else if (parser->current_token.type == TOKEN_IDENTIFIER) {
      free(parser->current_token.identifier_value);
    }
  }
  
  // Destroy symbol table
  if (parser->symbols != NULL) {
    symbol_table_destroy(parser->symbols);
  }
  
  free(parser);
}

/**
 * @brief Get the current line number
 * 
 * @param parser The parser instance
 * @return Current line number
 */
size_t parser_line(const parser_t* parser) {
  if (parser == NULL) {
    return 0;
  }
  
  if (parser->has_current_token) {
    return parser->current_token.line;
  }
  
  return lexer_line(parser->lexer);
}

/**
 * @brief Get the current column number
 * 
 * @param parser The parser instance
 * @return Current column number
 */
size_t parser_column(const parser_t* parser) {
  if (parser == NULL) {
    return 0;
  }
  
  if (parser->has_current_token) {
    return parser->current_token.column;
  }
  
  return lexer_column(parser->lexer);
}

/**
 * @brief Get the source filename
 * 
 * @param parser The parser instance
 * @return Source filename
 */
const char* parser_filename(const parser_t* parser) {
  if (parser == NULL) {
    return "<unknown>";
  }
  
  return lexer_filename(parser->lexer);
}

/**
 * @brief Parse a type reference
 * 
 * @param parser Parser instance
 * @return Parsed type or NULL on error
 */
ast_type_t* parser_parse_type(parser_t* parser) {
  // Parse the base type
  token_t token = peek(parser);
  
  if (token.type == TOKEN_IDENTIFIER) {
    advance(parser);
    
    // Check for vector, array, or pointer type
    if (check(parser, TOKEN_LESS)) {
      // Vector or pointer type
      advance(parser);
      
      if (check(parser, TOKEN_IDENTIFIER)) {
        // Vector type: vec<element_type, count>
        token_t element_token = peek(parser);
        advance(parser);
        
        // Create element type
        ast_type_def_t* element_type_def = symbol_table_lookup_type(parser->symbols, element_token.identifier_value);
        if (element_type_def == NULL) {
          syntax_error(parser, "Unknown type '%s'", element_token.identifier_value);
          return NULL;
        }
        
        ast_type_t* element_type = ast_type_create(element_type_def->type.category);
        if (element_type == NULL) {
          return NULL;
        }
        
        // Copy relevant fields from the type definition
        memcpy(element_type, &element_type_def->type, sizeof(ast_type_t));
        
        // Expect comma
        if (!expect(parser, TOKEN_COMMA, "Expected ',' after vector element type")) {
          ast_type_destroy(element_type);
          return NULL;
        }
        
        // Expect element count
        if (!expect(parser, TOKEN_NUMBER, "Expected element count in vector type")) {
          ast_type_destroy(element_type);
          return NULL;
        }
        
        uint32_t element_count = (uint32_t)parser->previous_token.number_value;
        
        // Expect closing '>'
        if (!expect(parser, TOKEN_GREATER, "Expected '>' after vector element count")) {
          ast_type_destroy(element_type);
          return NULL;
        }
        
        // Create vector type
        return ast_type_create_vector(element_type, element_count);
      } else if (check(parser, TOKEN_IDENTIFIER)) {
        // Pointer to specific memory space: ptr<type, space>
        token_t element_token = peek(parser);
        advance(parser);
        
        ast_type_def_t* element_type_def = symbol_table_lookup_type(parser->symbols, element_token.identifier_value);
        if (element_type_def == NULL) {
          syntax_error(parser, "Unknown type '%s'", element_token.identifier_value);
          return NULL;
        }
        
        ast_type_t* element_type = ast_type_create(element_type_def->type.category);
        if (element_type == NULL) {
          return NULL;
        }
        
        memcpy(element_type, &element_type_def->type, sizeof(ast_type_t));
        
        // Default memory space
        memory_space_t space = MEMORY_DEFAULT;
        
        // Check for memory space
        if (check(parser, TOKEN_COMMA)) {
          advance(parser);
          
          if (!expect(parser, TOKEN_IDENTIFIER, "Expected memory space after comma")) {
            ast_type_destroy(element_type);
            return NULL;
          }
          
          // Determine memory space
          if (strcmp(parser->previous_token.identifier_value, "global") == 0) {
            space = MEMORY_GLOBAL;
          } else if (strcmp(parser->previous_token.identifier_value, "local") == 0) {
            space = MEMORY_LOCAL;
          } else if (strcmp(parser->previous_token.identifier_value, "shared") == 0) {
            space = MEMORY_SHARED;
          } else if (strcmp(parser->previous_token.identifier_value, "constant") == 0) {
            space = MEMORY_CONSTANT;
          } else if (strcmp(parser->previous_token.identifier_value, "private") == 0) {
            space = MEMORY_PRIVATE;
          } else {
            syntax_error(parser, "Unknown memory space '%s'", parser->previous_token.identifier_value);
            ast_type_destroy(element_type);
            return NULL;
          }
        }
        
        // Expect closing '>'
        if (!expect(parser, TOKEN_GREATER, "Expected '>' after pointer type")) {
          ast_type_destroy(element_type);
          return NULL;
        }
        
        // Create pointer type
        return ast_type_create_pointer(element_type, space);
      } else {
        syntax_error(parser, "Expected type after '<'");
        return NULL;
      }
    } else if (check(parser, TOKEN_LBRACKET)) {
      // Array type: array<element_type> or array<element_type, count>
      advance(parser);
      
      // Array element type
      token_t element_token = peek(parser);
      if (!expect(parser, TOKEN_IDENTIFIER, "Expected element type after 'array<'")) {
        return NULL;
      }
      
      ast_type_def_t* element_type_def = symbol_table_lookup_type(parser->symbols, element_token.identifier_value);
      if (element_type_def == NULL) {
        syntax_error(parser, "Unknown type '%s'", element_token.identifier_value);
        return NULL;
      }
      
      ast_type_t* element_type = ast_type_create(element_type_def->type.category);
      if (element_type == NULL) {
        return NULL;
      }
      
      memcpy(element_type, &element_type_def->type, sizeof(ast_type_t));
      
      // Check for array size
      uint32_t element_count = 0;  // 0 means unsized array
      
      if (check(parser, TOKEN_COMMA)) {
        advance(parser);
        
        if (!expect(parser, TOKEN_NUMBER, "Expected array size after comma")) {
          ast_type_destroy(element_type);
          return NULL;
        }
        
        element_count = (uint32_t)parser->previous_token.number_value;
      }
      
      // Expect closing '>'
      if (!expect(parser, TOKEN_GREATER, "Expected '>' after array type")) {
        ast_type_destroy(element_type);
        return NULL;
      }
      
      // Create array type
      return ast_type_create_array(element_type, element_count);
    } else {
      // Named type (struct or basic type)
      
      // Look up type in symbol table
      ast_type_def_t* type_def = symbol_table_lookup_type(parser->symbols, token.identifier_value);
      if (type_def == NULL) {
        // Check for built-in types
        if (strcmp(token.identifier_value, "void") == 0) {
          return ast_type_create(TYPE_VOID);
        } else if (strcmp(token.identifier_value, "bool") == 0) {
          return ast_type_create(TYPE_BOOLEAN);
        } else if (strcmp(token.identifier_value, "i8") == 0) {
          return ast_type_create_integer(8, false);
        } else if (strcmp(token.identifier_value, "u8") == 0) {
          return ast_type_create_integer(8, true);
        } else if (strcmp(token.identifier_value, "i16") == 0) {
          return ast_type_create_integer(16, false);
        } else if (strcmp(token.identifier_value, "u16") == 0) {
          return ast_type_create_integer(16, true);
        } else if (strcmp(token.identifier_value, "i32") == 0) {
          return ast_type_create_integer(32, false);
        } else if (strcmp(token.identifier_value, "u32") == 0) {
          return ast_type_create_integer(32, true);
        } else if (strcmp(token.identifier_value, "i64") == 0) {
          return ast_type_create_integer(64, false);
        } else if (strcmp(token.identifier_value, "u64") == 0) {
          return ast_type_create_integer(64, true);
        } else if (strcmp(token.identifier_value, "f16") == 0) {
          return ast_type_create_float(16);
        } else if (strcmp(token.identifier_value, "f32") == 0) {
          return ast_type_create_float(32);
        } else if (strcmp(token.identifier_value, "f64") == 0) {
          return ast_type_create_float(64);
        } else {
          syntax_error(parser, "Unknown type '%s'", token.identifier_value);
          return NULL;
        }
      }
      
      // Create a copy of the type from the definition
      ast_type_t* type = ast_type_create(type_def->type.category);
      if (type == NULL) {
        return NULL;
      }
      
      memcpy(type, &type_def->type, sizeof(ast_type_t));
      
      return type;
    }
  } else {
    syntax_error(parser, "Expected type");
    return NULL;
  }
}

/**
 * @brief Parse a constant expression
 * 
 * @param parser Parser instance
 * @param type Expected type of the constant
 * @return Parsed constant or NULL on error
 */
static ast_constant_t* parse_constant_expression(parser_t* parser, ast_type_t* type) {
  token_t token = peek(parser);
  
  // Create a temporary constant for the value
  ast_constant_t* constant = ast_constant_create("_literal", type);
  if (constant == NULL) {
    return NULL;
  }
  
  switch (token.type) {
    case TOKEN_NUMBER:
      advance(parser);
      
      // Set the appropriate value based on type
      if (type->category == TYPE_INTEGER) {
        constant->value_type = CONSTANT_INTEGER;
        constant->int_value = (int64_t)token.number_value;
      } else if (type->category == TYPE_FLOAT) {
        constant->value_type = CONSTANT_FLOAT;
        constant->float_value = token.number_value;
      } else {
        syntax_error(parser, "Numeric literal doesn't match expected type");
        ast_constant_destroy(constant);
        return NULL;
      }
      break;
      
    case TOKEN_STRING:
      advance(parser);
      
      // Check if type is an array of characters
      if (type->category == TYPE_ARRAY && 
          type->array.element_type != NULL && 
          type->array.element_type->category == TYPE_INTEGER && 
          type->array.element_type->integer.bit_width == 8) {
        
        constant->value_type = CONSTANT_STRING;
        constant->string_value = strdup(token.string_value);
        if (constant->string_value == NULL) {
          error_report(ERROR_MEMORY, "Failed to allocate memory for string constant");
          ast_constant_destroy(constant);
          return NULL;
        }
      } else {
        syntax_error(parser, "String literal doesn't match expected type");
        ast_constant_destroy(constant);
        return NULL;
      }
      break;
      
    case TOKEN_IDENTIFIER:
      advance(parser);
      
      // Check if it's a named constant
      ast_constant_t* named_constant = symbol_table_lookup_constant(parser->symbols, token.identifier_value);
      if (named_constant == NULL) {
        syntax_error(parser, "Unknown constant '%s'", token.identifier_value);
        ast_constant_destroy(constant);
        return NULL;
      }
      
      // Copy the value from the named constant
      // This is a simplification; in a real implementation, we would need
      // to check type compatibility and handle complex constants better
      constant->value_type = named_constant->value_type;
      
      switch (named_constant->value_type) {
        case CONSTANT_INTEGER:
          constant->int_value = named_constant->int_value;
          break;
          
        case CONSTANT_FLOAT:
          constant->float_value = named_constant->float_value;
          break;
          
        case CONSTANT_BOOLEAN:
          constant->bool_value = named_constant->bool_value;
          break;
          
        case CONSTANT_STRING:
          constant->string_value = strdup(named_constant->string_value);
          if (constant->string_value == NULL) {
            error_report(ERROR_MEMORY, "Failed to allocate memory for string constant");
            ast_constant_destroy(constant);
            return NULL;
          }
          break;
          
        default:
          syntax_error(parser, "Unsupported constant type");
          ast_constant_destroy(constant);
          return NULL;
      }
      break;
      
    default:
      syntax_error(parser, "Expected constant expression");
      ast_constant_destroy(constant);
      return NULL;
  }
  
  return constant;
}

/**
 * @brief Parse a type definition
 * 
 * @param parser Parser instance
 * @return Parsed type definition or NULL on error
 */
ast_type_def_t* parser_parse_type_def(parser_t* parser) {
  // Expect 'TYPE' keyword
  if (!expect(parser, TOKEN_TYPE, "Expected 'TYPE'")) {
    return NULL;
  }
  
  // Expect type name
  if (!expect(parser, TOKEN_IDENTIFIER, "Expected type name")) {
    return NULL;
  }
  
  const char* type_name = parser->previous_token.identifier_value;
  
  // Create type definition for structure
  ast_type_def_t* type_def = ast_type_def_create(type_name, TYPE_STRUCTURE);
  if (type_def == NULL) {
    return NULL;
  }
  
  // Add to symbol table
  if (!symbol_table_add_type(parser->symbols, type_name, type_def, parser_line(parser), parser_column(parser))) {
    syntax_error(parser, "Type '%s' already defined", type_name);
    free(type_def);
    return NULL;
  }
  
  // Expect opening brace
  if (!expect(parser, TOKEN_LBRACE, "Expected '{' after type name")) {
    return NULL;
  }
  
  // Parse field definitions
  size_t field_count = 0;
  size_t field_capacity = 8;
  ast_struct_field_t* fields = (ast_struct_field_t*)malloc(field_capacity * sizeof(ast_struct_field_t));
  if (fields == NULL) {
    error_report(ERROR_MEMORY, "Failed to allocate memory for type fields");
    return NULL;
  }
  
  uint32_t offset = 0;
  uint32_t max_alignment = 1;
  
  while (!check(parser, TOKEN_RBRACE) && !check(parser, TOKEN_EOF)) {
    // Expect field name
    if (!expect(parser, TOKEN_IDENTIFIER, "Expected field name")) {
      free(fields);
      return NULL;
    }
    
    const char* field_name = parser->previous_token.identifier_value;
    
    // Expect colon
    if (!expect(parser, TOKEN_COLON, "Expected ':' after field name")) {
      free(fields);
      return NULL;
    }
    
    // Parse field type
    ast_type_t* field_type = parser_parse_type(parser);
    if (field_type == NULL) {
      free(fields);
      return NULL;
    }
    
    // Calculate field offset with alignment
    uint32_t alignment = coil_type_alignment(field_type);
    uint32_t aligned_offset = (offset + alignment - 1) & ~(alignment - 1);
    offset = aligned_offset;
    
    // Update maximum alignment
    if (alignment > max_alignment) {
      max_alignment = alignment;
    }
    
    // Expect semicolon
    if (!expect(parser, TOKEN_SEMICOLON, "Expected ';' after field type")) {
      ast_type_destroy(field_type);
      free(fields);
      return NULL;
    }
    
    // Add field to array
    if (field_count >= field_capacity) {
      field_capacity *= 2;
      ast_struct_field_t* new_fields = (ast_struct_field_t*)realloc(fields, field_capacity * sizeof(ast_struct_field_t));
      if (new_fields == NULL) {
        error_report(ERROR_MEMORY, "Failed to resize field array");
        ast_type_destroy(field_type);
        free(fields);
        return NULL;
      }
      fields = new_fields;
    }
    
    fields[field_count].name = strdup(field_name);
    if (fields[field_count].name == NULL) {
      error_report(ERROR_MEMORY, "Failed to allocate memory for field name");
      ast_type_destroy(field_type);
      free(fields);
      return NULL;
    }
    
    fields[field_count].type = field_type;
    fields[field_count].offset = offset;
    
    // Update offset for next field
    offset += coil_type_size(field_type);
    field_count++;
  }
  
  // Expect closing brace
  if (!expect(parser, TOKEN_RBRACE, "Expected '}' after fields")) {
    for (size_t i = 0; i < field_count; i++) {
      free((void*)fields[i].name);
      ast_type_destroy(fields[i].type);
    }
    free(fields);
    return NULL;
  }
  
  // Finalize structure size
  uint32_t total_size = (offset + max_alignment - 1) & ~(max_alignment - 1);
  
  // Update type definition
  type_def->fields = fields;
  type_def->field_count = field_count;
  type_def->size = total_size;
  type_def->alignment = max_alignment;
  
  // Update structure type
  type_def->type.structure.name = strdup(type_name);
  if (type_def->type.structure.name == NULL) {
    error_report(ERROR_MEMORY, "Failed to allocate memory for structure name");
    return NULL;
  }
  
  type_def->type.structure.def = type_def;
  
  return type_def;
}

/**
 * @brief Parse a constant declaration
 * 
 * @param parser Parser instance
 * @return Parsed constant or NULL on error
 */
ast_constant_t* parser_parse_constant(parser_t* parser) {
  // Expect 'CONSTANT' keyword
  if (!expect(parser, TOKEN_CONSTANT, "Expected 'CONSTANT'")) {
    return NULL;
  }
  
  // Expect constant name
  if (!expect(parser, TOKEN_IDENTIFIER, "Expected constant name")) {
    return NULL;
  }
  
  const char* constant_name = parser->previous_token.identifier_value;
  
  // Expect colon
  if (!expect(parser, TOKEN_COLON, "Expected ':' after constant name")) {
    return NULL;
  }
  
  // Parse constant type
  ast_type_t* constant_type = parser_parse_type(parser);
  if (constant_type == NULL) {
    return NULL;
  }
  
  // Expect equals
  if (!expect(parser, TOKEN_EQUALS, "Expected '=' after constant type")) {
    ast_type_destroy(constant_type);
    return NULL;
  }
  
  // Parse constant value
  ast_constant_t* value = parse_constant_expression(parser, constant_type);
  if (value == NULL) {
    ast_type_destroy(constant_type);
    return NULL;
  }
  
  // Expect semicolon
  if (!expect(parser, TOKEN_SEMICOLON, "Expected ';' after constant value")) {
    ast_constant_destroy(value);
    return NULL;
  }
  
  // Create constant
  ast_constant_t* constant = ast_constant_create(constant_name, constant_type);
  if (constant == NULL) {
    ast_constant_destroy(value);
    return NULL;
  }
  
  // Copy value from the parsed expression
  constant->value_type = value->value_type;
  
  switch (value->value_type) {
    case CONSTANT_INTEGER:
      constant->int_value = value->int_value;
      break;
      
    case CONSTANT_FLOAT:
      constant->float_value = value->float_value;
      break;
      
    case CONSTANT_BOOLEAN:
      constant->bool_value = value->bool_value;
      break;
      
    case CONSTANT_STRING:
      constant->string_value = strdup(value->string_value);
      if (constant->string_value == NULL) {
        error_report(ERROR_MEMORY, "Failed to allocate memory for string constant");
        ast_constant_destroy(value);
        ast_constant_destroy(constant);
        return NULL;
      }
      break;
      
    default:
      syntax_error(parser, "Unsupported constant type");
      ast_constant_destroy(value);
      ast_constant_destroy(constant);
      return NULL;
  }
  
  // Add to symbol table
  if (!symbol_table_add_constant(parser->symbols, constant_name, constant, parser_line(parser), parser_column(parser))) {
    syntax_error(parser, "Constant '%s' already defined", constant_name);
    ast_constant_destroy(value);
    ast_constant_destroy(constant);
    return NULL;
  }
  
  // Clean up temporary value
  ast_constant_destroy(value);
  
  return constant;
}

/**
 * @brief Parse a global variable declaration
 * 
 * @param parser Parser instance
 * @return Parsed global variable or NULL on error
 */
ast_global_t* parser_parse_global(parser_t* parser) {
  // Expect 'GLOBAL' keyword
  if (!expect(parser, TOKEN_GLOBAL, "Expected 'GLOBAL'")) {
    return NULL;
  }
  
  // Expect global name
  if (!expect(parser, TOKEN_IDENTIFIER, "Expected global variable name")) {
    return NULL;
  }
  
  const char* global_name = parser->previous_token.identifier_value;
  
  // Expect colon
  if (!expect(parser, TOKEN_COLON, "Expected ':' after global name")) {
    return NULL;
  }
  
  // Parse global type
  ast_type_t* global_type = parser_parse_type(parser);
  if (global_type == NULL) {
    return NULL;
  }
  
  // Create global
  ast_global_t* global = ast_global_create(global_name, global_type);
  if (global == NULL) {
    return NULL;
  }
  
  // Check for initializer
  if (check(parser, TOKEN_EQUALS)) {
    advance(parser);
    
    // Parse initializer
    ast_constant_t* initializer = parse_constant_expression(parser, global_type);
    if (initializer == NULL) {
      ast_global_destroy(global);
      return NULL;
    }
    
    global->has_initializer = true;
    global->initializer = initializer;
  }
  
  // Expect semicolon
  if (!expect(parser, TOKEN_SEMICOLON, "Expected ';' after global declaration")) {
    ast_global_destroy(global);
    return NULL;
  }
  
  // Add to symbol table
  if (!symbol_table_add_global(parser->symbols, global_name, global, parser_line(parser), parser_column(parser))) {
    syntax_error(parser, "Global '%s' already defined", global_name);
    ast_global_destroy(global);
    return NULL;
  }
  
  return global;
}

/**
 * @brief Parse a target specification
 * 
 * @param parser Parser instance
 * @return Parsed target specification or NULL on error
 */
ast_target_t* parser_parse_target(parser_t* parser) {
  // Expect 'TARGET' keyword
  if (!expect(parser, TOKEN_TARGET, "Expected 'TARGET'")) {
    return NULL;
  }
  
  // Check for string literal (device class)
  const char* device_class = "CPU";  // Default to CPU
  
  if (check(parser, TOKEN_STRING)) {
    advance(parser);
    device_class = parser->previous_token.string_value;
  }
  
  // Create target
  ast_target_t* target = ast_target_create(device_class);
  if (target == NULL) {
    return NULL;
  }
  
  // Expect opening brace
  if (!expect(parser, TOKEN_LBRACE, "Expected '{' after TARGET")) {
    ast_target_destroy(target);
    return NULL;
  }
  
  // Parse target properties
  while (!check(parser, TOKEN_RBRACE) && !check(parser, TOKEN_EOF)) {
    // Expect property name
    if (!expect(parser, TOKEN_IDENTIFIER, "Expected property name")) {
      ast_target_destroy(target);
      return NULL;
    }
    
    const char* property_name = parser->previous_token.identifier_value;
    
    // Expect equals
    if (!expect(parser, TOKEN_EQUALS, "Expected '=' after property name")) {
      ast_target_destroy(target);
      return NULL;
    }
    
    // Parse property value
    if (strcmp(property_name, "required_features") == 0) {
      // Expect array of strings
      if (!expect(parser, TOKEN_LBRACKET, "Expected '[' for required_features")) {
        ast_target_destroy(target);
        return NULL;
      }
      
      while (!check(parser, TOKEN_RBRACKET) && !check(parser, TOKEN_EOF)) {
        // Parse string
        if (!expect(parser, TOKEN_STRING, "Expected feature name string")) {
          ast_target_destroy(target);
          return NULL;
        }
        
        const char* feature = parser->previous_token.string_value;
        
        // Add to required features
        if (!ast_target_add_required_feature(target, feature)) {
          ast_target_destroy(target);
          return NULL;
        }
        
        // Check for comma
        if (check(parser, TOKEN_COMMA)) {
          advance(parser);
        } else {
          break;
        }
      }
      
      if (!expect(parser, TOKEN_RBRACKET, "Expected ']' after features")) {
        ast_target_destroy(target);
        return NULL;
      }
    } else if (strcmp(property_name, "preferred_features") == 0) {
      // Expect array of strings
      if (!expect(parser, TOKEN_LBRACKET, "Expected '[' for preferred_features")) {
        ast_target_destroy(target);
        return NULL;
      }
      
      while (!check(parser, TOKEN_RBRACKET) && !check(parser, TOKEN_EOF)) {
        // Parse string
        if (!expect(parser, TOKEN_STRING, "Expected feature name string")) {
          ast_target_destroy(target);
          return NULL;
        }
        
        const char* feature = parser->previous_token.string_value;
        
        // Add to preferred features
        if (!ast_target_add_preferred_feature(target, feature)) {
          ast_target_destroy(target);
          return NULL;
        }
        
        // Check for comma
        if (check(parser, TOKEN_COMMA)) {
          advance(parser);
        } else {
          break;
        }
      }
      
      if (!expect(parser, TOKEN_RBRACKET, "Expected ']' after features")) {
        ast_target_destroy(target);
        return NULL;
      }
    } else if (strcmp(property_name, "device_class") == 0) {
      // Expect string
      if (!expect(parser, TOKEN_STRING, "Expected device class string")) {
        ast_target_destroy(target);
        return NULL;
      }
      
      // Update device class
      free((void*)target->device_class);
      target->device_class = strdup(parser->previous_token.string_value);
      if (target->device_class == NULL) {
        error_report(ERROR_MEMORY, "Failed to allocate memory for device class");
        ast_target_destroy(target);
        return NULL;
      }
    } else {
      syntax_error(parser, "Unknown target property '%s'", property_name);
      ast_target_destroy(target);
      return NULL;
    }
    
    // Expect optional semicolon
    if (check(parser, TOKEN_SEMICOLON)) {
      advance(parser);
    }
  }
  
  // Expect closing brace
  if (!expect(parser, TOKEN_RBRACE, "Expected '}' after target properties")) {
    ast_target_destroy(target);
    return NULL;
  }
  
  return target;
}

/**
 * @brief Parse an operand for an instruction
 * 
 * @param parser Parser instance
 * @return Parsed operand or NULL on error
 */
static ast_operand_t* parse_operand(parser_t* parser) {
  token_t token = peek(parser);
  
  switch (token.type) {
    case TOKEN_IDENTIFIER:
      {
        advance(parser);
        const char* name = token.identifier_value;
        
        // Check if it's a local variable, parameter, or global
        ast_operand_t* local = symbol_table_lookup_variable(parser->symbols, name);
        if (local != NULL) {
          // Local variable or parameter
          return local;
        }
        
        ast_global_t* global = symbol_table_lookup_global(parser->symbols, name);
        if (global != NULL) {
          // Global variable
          return ast_operand_create_global(name, global->type);
        }
        
        ast_constant_t* constant = symbol_table_lookup_constant(parser->symbols, name);
        if (constant != NULL) {
          // Constant
          return ast_operand_create_constant(constant);
        }
        
        ast_function_t* function = symbol_table_lookup_function(parser->symbols, name);
        if (function != NULL) {
          // Function reference
          return ast_operand_create_function(name, function->return_type);
        }
        
        ast_basic_block_t* block = symbol_table_lookup_block(parser->symbols, name);
        if (block != NULL) {
          // Basic block reference
          return ast_operand_create_block(name);
        }
        
        // Not found
        syntax_error(parser, "Unknown identifier '%s'", name);
        return NULL;
      }
      
    case TOKEN_NUMBER:
      {
        advance(parser);
        // For now, we'll treat all numeric literals as i32
        ast_type_t* type = ast_type_create_integer(32, false);
        if (type == NULL) {
          return NULL;
        }
        
        ast_constant_t* constant = ast_constant_create("_literal", type);
        if (constant == NULL) {
          ast_type_destroy(type);
          return NULL;
        }
        
        constant->value_type = CONSTANT_INTEGER;
        constant->int_value = (int64_t)token.number_value;
        
        return ast_operand_create_constant(constant);
      }
      
    case TOKEN_STRING:
      {
        advance(parser);
        // Create an array type for the string
        ast_type_t* char_type = ast_type_create_integer(8, true);
        if (char_type == NULL) {
          return NULL;
        }
        
        ast_type_t* array_type = ast_type_create_array(char_type, strlen(token.string_value) + 1);
        if (array_type == NULL) {
          ast_type_destroy(char_type);
          return NULL;
        }
        
        ast_constant_t* constant = ast_constant_create("_literal", array_type);
        if (constant == NULL) {
          ast_type_destroy(array_type);
          return NULL;
        }
        
        constant->value_type = CONSTANT_STRING;
        constant->string_value = strdup(token.string_value);
        if (constant->string_value == NULL) {
          error_report(ERROR_MEMORY, "Failed to allocate memory for string constant");
          ast_constant_destroy(constant);
          return NULL;
        }
        
        return ast_operand_create_constant(constant);
      }
      
    case TOKEN_LBRACKET:
      {
        // Memory access operand
        advance(parser);
        
        // Parse inner operand (pointer)
        ast_operand_t* ptr_operand = parse_operand(parser);
        if (ptr_operand == NULL) {
          return NULL;
        }
        
        // Check that it's a pointer
        if (ptr_operand->value_type == NULL || ptr_operand->value_type->category != TYPE_POINTER) {
          syntax_error(parser, "Expected pointer for memory access");
          ast_operand_destroy(ptr_operand);
          return NULL;
        }
        
        // Expect closing bracket
        if (!expect(parser, TOKEN_RBRACKET, "Expected ']' after memory address")) {
          ast_operand_destroy(ptr_operand);
          return NULL;
        }
        
        // For simplicity, we'll just return the pointer operand
        // In a real implementation, we would create a memory access operand
        return ptr_operand;
      }
      
    default:
      syntax_error(parser, "Expected operand");
      return NULL;
  }
}

/**
 * @brief Parse an instruction
 * 
 * @param parser Parser instance
 * @return Parsed instruction or NULL on error
 */
static ast_instruction_t* parse_instruction(parser_t* parser) {
  // Check for result assignment
  ast_operand_t* result = NULL;
  
  if (check(parser, TOKEN_IDENTIFIER)) {
    token_t token = peek(parser);
    advance(parser);
    
    if (check(parser, TOKEN_EQUALS)) {
      advance(parser);
      
      // Create a local variable for the result
      const char* name = token.identifier_value;
      
      // Create a placeholder type that will be updated once we know the instruction
      ast_type_t* placeholder_type = ast_type_create_integer(32, false);
      if (placeholder_type == NULL) {
        return NULL;
      }
      
      result = ast_operand_create_local(name, placeholder_type);
      if (result == NULL) {
        ast_type_destroy(placeholder_type);
        return NULL;
      }
      
      // Add to symbol table
      if (!symbol_table_add_local(parser->symbols, name, result, parser_line(parser), parser_column(parser))) {
        syntax_error(parser, "Variable '%s' already defined", name);
        ast_operand_destroy(result);
        return NULL;
      }
    } else {
      // Not an assignment, push the token back
      parser->has_current_token = false;
    }
  }
  
  // Parse instruction opcode
  token_t token = peek(parser);
  opcode_t opcode;
  
  switch (token.type) {
    case TOKEN_ADD: opcode = OPCODE_ADD; break;
    case TOKEN_SUB: opcode = OPCODE_SUB; break;
    case TOKEN_MUL: opcode = OPCODE_MUL; break;
    case TOKEN_DIV: opcode = OPCODE_DIV; break;
    case TOKEN_REM: opcode = OPCODE_REM; break;
    case TOKEN_NEG: opcode = OPCODE_NEG; break;
    case TOKEN_AND: opcode = OPCODE_AND; break;
    case TOKEN_OR: opcode = OPCODE_OR; break;
    case TOKEN_XOR: opcode = OPCODE_XOR; break;
    case TOKEN_NOT: opcode = OPCODE_NOT; break;
    case TOKEN_SHL: opcode = OPCODE_SHL; break;
    case TOKEN_SHR: opcode = OPCODE_SHR; break;
    case TOKEN_CMP_EQ: opcode = OPCODE_CMP_EQ; break;
    case TOKEN_CMP_NE: opcode = OPCODE_CMP_NE; break;
    case TOKEN_CMP_LT: opcode = OPCODE_CMP_LT; break;
    case TOKEN_CMP_LE: opcode = OPCODE_CMP_LE; break;
    case TOKEN_CMP_GT: opcode = OPCODE_CMP_GT; break;
    case TOKEN_CMP_GE: opcode = OPCODE_CMP_GE; break;
    case TOKEN_LOAD: opcode = OPCODE_LOAD; break;
    case TOKEN_STORE: opcode = OPCODE_STORE; break;
    case TOKEN_LEA: opcode = OPCODE_LEA; break;
    case TOKEN_FENCE: opcode = OPCODE_FENCE; break;
    case TOKEN_BR: opcode = OPCODE_BR; break;
    case TOKEN_CALL: opcode = OPCODE_CALL; break;
    case TOKEN_RET: opcode = OPCODE_RET; break;
    case TOKEN_CONVERT: opcode = OPCODE_CONVERT; break;
    case TOKEN_TRUNC: opcode = OPCODE_TRUNC; break;
    case TOKEN_EXTEND: opcode = OPCODE_EXTEND; break;
    case TOKEN_VADD: opcode = OPCODE_VADD; break;
    case TOKEN_VDOT: opcode = OPCODE_VDOT; break;
    case TOKEN_VSPLAT: opcode = OPCODE_VSPLAT; break;
    case TOKEN_VLOAD: opcode = OPCODE_VLOAD; break;
    case TOKEN_ATOMIC_ADD: opcode = OPCODE_ATOMIC_ADD; break;
    case TOKEN_ATOMIC_CAS: opcode = OPCODE_ATOMIC_CAS; break;
    default:
      if (result != NULL) {
        syntax_error(parser, "Expected instruction opcode");
        ast_operand_destroy(result);
        return NULL;
      } else {
        return NULL;  // Not an instruction
      }
  }
  
  advance(parser);
  
  // Create instruction
  ast_instruction_t* instruction = ast_instruction_create(opcode);
  if (instruction == NULL) {
    if (result != NULL) {
      ast_operand_destroy(result);
    }
    return NULL;
  }
  
  // Set result operand
  if (result != NULL) {
    ast_instruction_set_result(instruction, result);
  }
  
  // Parse operands based on opcode
  switch (opcode) {
    case OPCODE_ADD:
    case OPCODE_SUB:
    case OPCODE_MUL:
    case OPCODE_DIV:
    case OPCODE_REM:
    case OPCODE_AND:
    case OPCODE_OR:
    case OPCODE_XOR:
    case OPCODE_SHL:
    case OPCODE_SHR:
    case OPCODE_CMP_EQ:
    case OPCODE_CMP_NE:
    case OPCODE_CMP_LT:
    case OPCODE_CMP_LE:
    case OPCODE_CMP_GT:
    case OPCODE_CMP_GE:
    case OPCODE_VADD:
      {
        // Binary operation with two operands
        ast_operand_t* op1 = parse_operand(parser);
        if (op1 == NULL) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        if (!ast_instruction_add_operand(instruction, op1)) {
          ast_operand_destroy(op1);
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        if (!expect(parser, TOKEN_COMMA, "Expected ',' between operands")) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        ast_operand_t* op2 = parse_operand(parser);
        if (op2 == NULL) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        if (!ast_instruction_add_operand(instruction, op2)) {
          ast_operand_destroy(op2);
          ast_instruction_destroy(instruction);
          return NULL;
        }
      }
      break;
      
    case OPCODE_NEG:
    case OPCODE_NOT:
    case OPCODE_LOAD:
    case OPCODE_LEA:
    case OPCODE_VLOAD:
      {
        // Unary operation with one operand
        ast_operand_t* op = parse_operand(parser);
        if (op == NULL) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        if (!ast_instruction_add_operand(instruction, op)) {
          ast_operand_destroy(op);
          ast_instruction_destroy(instruction);
          return NULL;
        }
      }
      break;
      
    case OPCODE_STORE:
      {
        // Store has destination and value operands
        ast_operand_t* dst = parse_operand(parser);
        if (dst == NULL) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        if (!ast_instruction_add_operand(instruction, dst)) {
          ast_operand_destroy(dst);
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        if (!expect(parser, TOKEN_COMMA, "Expected ',' between operands")) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        ast_operand_t* value = parse_operand(parser);
        if (value == NULL) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        if (!ast_instruction_add_operand(instruction, value)) {
          ast_operand_destroy(value);
          ast_instruction_destroy(instruction);
          return NULL;
        }
      }
      break;
      
    case OPCODE_BR:
      {
        // Branch can be conditional or unconditional
        ast_operand_t* condition = parse_operand(parser);
        if (condition == NULL) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        if (!ast_instruction_add_operand(instruction, condition)) {
          ast_operand_destroy(condition);
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        if (!expect(parser, TOKEN_COMMA, "Expected ',' after condition")) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        // Parse true branch target
        ast_operand_t* true_target = parse_operand(parser);
        if (true_target == NULL) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        if (!ast_instruction_add_operand(instruction, true_target)) {
          ast_operand_destroy(true_target);
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        // Check if this is a conditional branch with a false target
        if (check(parser, TOKEN_COMMA)) {
          advance(parser);
          
          // Parse false branch target
          ast_operand_t* false_target = parse_operand(parser);
          if (false_target == NULL) {
            ast_instruction_destroy(instruction);
            return NULL;
          }
          
          if (!ast_instruction_add_operand(instruction, false_target)) {
            ast_operand_destroy(false_target);
            ast_instruction_destroy(instruction);
            return NULL;
          }
          
          // Set branch info for conditional branch
          instruction->branch_info.is_conditional = true;
          
          if (true_target->type == OPERAND_BLOCK) {
            instruction->branch_info.true_label = true_target->block.name;
          } else {
            syntax_error(parser, "Branch target must be a block label");
            ast_instruction_destroy(instruction);
            return NULL;
          }
          
          if (false_target->type == OPERAND_BLOCK) {
            instruction->branch_info.false_label = false_target->block.name;
          } else {
            syntax_error(parser, "Branch target must be a block label");
            ast_instruction_destroy(instruction);
            return NULL;
          }
        } else {
          // Unconditional branch
          instruction->branch_info.is_conditional = false;
          
          if (true_target->type == OPERAND_BLOCK) {
            instruction->branch_info.true_label = true_target->block.name;
          } else {
            syntax_error(parser, "Branch target must be a block label");
            ast_instruction_destroy(instruction);
            return NULL;
          }
          
          instruction->branch_info.false_label = NULL;
        }
      }
      break;
      
    case OPCODE_CALL:
      {
        // Call to a function
        ast_operand_t* func = parse_operand(parser);
        if (func == NULL) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        if (!ast_instruction_add_operand(instruction, func)) {
          ast_operand_destroy(func);
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        // Expect opening parenthesis
        if (!expect(parser, TOKEN_LPAREN, "Expected '(' after function name")) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        // Parse arguments
        bool is_first = true;
        while (!check(parser, TOKEN_RPAREN) && !check(parser, TOKEN_EOF)) {
          if (!is_first) {
            if (!expect(parser, TOKEN_COMMA, "Expected ',' between arguments")) {
              ast_instruction_destroy(instruction);
              return NULL;
            }
          }
          
          ast_operand_t* arg = parse_operand(parser);
          if (arg == NULL) {
            ast_instruction_destroy(instruction);
            return NULL;
          }
          
          if (!ast_instruction_add_operand(instruction, arg)) {
            ast_operand_destroy(arg);
            ast_instruction_destroy(instruction);
            return NULL;
          }
          
          is_first = false;
        }
        
        // Expect closing parenthesis
        if (!expect(parser, TOKEN_RPAREN, "Expected ')' after arguments")) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        // Set call info
        if (func->type == OPERAND_FUNCTION) {
          // Look up function to get return type and vararg info
          ast_function_t* function = symbol_table_lookup_function(parser->symbols, func->function.name);
          if (function != NULL) {
            instruction->call_info.is_vararg = function->is_vararg;
            
            // Copy return type
            instruction->call_info.return_type = (ast_type_t*)malloc(sizeof(ast_type_t));
            if (instruction->call_info.return_type == NULL) {
              error_report(ERROR_MEMORY, "Failed to allocate memory for return type");
              ast_instruction_destroy(instruction);
              return NULL;
            }
            
            memcpy(instruction->call_info.return_type, function->return_type, sizeof(ast_type_t));
          }
        }
      }
      break;
      
    case OPCODE_RET:
      {
        // Return can have a value or be void
        if (!check(parser, TOKEN_SEMICOLON)) {
          // Return with value
          ast_operand_t* value = parse_operand(parser);
          if (value == NULL) {
            ast_instruction_destroy(instruction);
            return NULL;
          }
          
          if (!ast_instruction_add_operand(instruction, value)) {
            ast_operand_destroy(value);
            ast_instruction_destroy(instruction);
            return NULL;
          }
          
          instruction->return_info.has_value = true;
        } else {
          // Void return
          instruction->return_info.has_value = false;
        }
      }
      break;
      
    case OPCODE_CONVERT:
    case OPCODE_TRUNC:
    case OPCODE_EXTEND:
      {
        // Type conversion with source and target type
        ast_operand_t* src = parse_operand(parser);
        if (src == NULL) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        if (!ast_instruction_add_operand(instruction, src)) {
          ast_operand_destroy(src);
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        if (!expect(parser, TOKEN_COMMA, "Expected ',' after source operand")) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        // Parse target type
        ast_type_t* target_type = parser_parse_type(parser);
        if (target_type == NULL) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        // In a real implementation, we would add the target type to the instruction
        // For simplicity, we'll just destroy it for now
        ast_type_destroy(target_type);
      }
      break;
      
    case OPCODE_VDOT:
      {
        // Vector dot product
        ast_operand_t* vec1 = parse_operand(parser);
        if (vec1 == NULL) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        if (!ast_instruction_add_operand(instruction, vec1)) {
          ast_operand_destroy(vec1);
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        if (!expect(parser, TOKEN_COMMA, "Expected ',' between vector operands")) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        ast_operand_t* vec2 = parse_operand(parser);
        if (vec2 == NULL) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        if (!ast_instruction_add_operand(instruction, vec2)) {
          ast_operand_destroy(vec2);
          ast_instruction_destroy(instruction);
          return NULL;
        }
      }
      break;
      
    case OPCODE_VSPLAT:
      {
        // Splat scalar to vector
        ast_operand_t* scalar = parse_operand(parser);
        if (scalar == NULL) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        if (!ast_instruction_add_operand(instruction, scalar)) {
          ast_operand_destroy(scalar);
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        if (!expect(parser, TOKEN_COMMA, "Expected ',' after scalar value")) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        // Parse vector dimension
        if (!expect(parser, TOKEN_NUMBER, "Expected vector dimension")) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        // For simplicity, we'll create a constant for the dimension
        ast_type_t* int_type = ast_type_create_integer(32, false);
        if (int_type == NULL) {
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        ast_constant_t* dim_const = ast_constant_create("_dimension", int_type);
        if (dim_const == NULL) {
          ast_type_destroy(int_type);
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        dim_const->value_type = CONSTANT_INTEGER;
        dim_const->int_value = (int64_t)parser->previous_token.number_value;
        
        ast_operand_t* dim_operand = ast_operand_create_constant(dim_const);
        if (dim_operand == NULL) {
          ast_constant_destroy(dim_const);
          ast_instruction_destroy(instruction);
          return NULL;
        }
        
        if (!ast_instruction_add_operand(instruction, dim_operand)) {
          ast_operand_destroy(dim_operand);
          ast_instruction_destroy(instruction);
          return NULL;
        }
      }
      break;
      
    default:
      // Other instructions not fully implemented
      syntax_error(parser, "Instruction not yet implemented");
      ast_instruction_destroy(instruction);
      return NULL;
  }
  
  // Expect semicolon
  if (!expect(parser, TOKEN_SEMICOLON, "Expected ';' after instruction")) {
    ast_instruction_destroy(instruction);
    return NULL;
  }
  
  return instruction;
}

/**
 * @brief Parse a basic block
 * 
 * @param parser Parser instance
 * @return Parsed basic block or NULL on error
 */
static ast_basic_block_t* parse_basic_block(parser_t* parser) {
  // Expect block label
  if (!expect(parser, TOKEN_IDENTIFIER, "Expected block label")) {
    return NULL;
  }
  
  const char* block_name = parser->previous_token.identifier_value;
  
  // Expect colon
  if (!expect(parser, TOKEN_COLON, "Expected ':' after block label")) {
    return NULL;
  }
  
  // Check if this is the entry block
  bool is_entry = strcmp(block_name, "ENTRY") == 0;
  
  // Create block
  ast_basic_block_t* block = ast_basic_block_create(block_name, is_entry);
  if (block == NULL) {
    return NULL;
  }
  
  // Add to symbol table
  if (!symbol_table_add_block(parser->symbols, block_name, block, parser_line(parser), parser_column(parser))) {
    syntax_error(parser, "Block '%s' already defined", block_name);
    ast_basic_block_destroy(block);
    return NULL;
  }
  
  // Set current block
  parser->current_block = block;
  
  // Parse instructions
  size_t instruction_count = 0;
  size_t instruction_capacity = 8;
  ast_instruction_t** instructions = (ast_instruction_t**)malloc(instruction_capacity * sizeof(ast_instruction_t*));
  if (instructions == NULL) {
    error_report(ERROR_MEMORY, "Failed to allocate memory for instructions");
    ast_basic_block_destroy(block);
    return NULL;
  }
  
  while (!check(parser, TOKEN_IDENTIFIER) || !check(parser, TOKEN_COLON)) {
    // Try to parse an instruction
    ast_instruction_t* instruction = parse_instruction(parser);
    if (instruction == NULL) {
      // Not an instruction, check if it's the end of the block
      if (check(parser, TOKEN_IDENTIFIER) || check(parser, TOKEN_RBRACE) || check(parser, TOKEN_EOF)) {
        break;
      }
      
      // Skip to the next statement
      while (!check(parser, TOKEN_SEMICOLON) && !check(parser, TOKEN_IDENTIFIER) && 
             !check(parser, TOKEN_RBRACE) && !check(parser, TOKEN_EOF)) {
        advance(parser);
      }
      
      if (check(parser, TOKEN_SEMICOLON)) {
        advance(parser);
      }
      
      continue;
    }
    
    // Add instruction to block
    if (instruction_count >= instruction_capacity) {
      instruction_capacity *= 2;
      ast_instruction_t** new_instructions = (ast_instruction_t**)realloc(instructions, instruction_capacity * sizeof(ast_instruction_t*));
      if (new_instructions == NULL) {
        error_report(ERROR_MEMORY, "Failed to resize instructions array");
        for (size_t i = 0; i < instruction_count; i++) {
          ast_instruction_destroy(instructions[i]);
        }
        free(instructions);
        ast_basic_block_destroy(block);
        return NULL;
      }
      instructions = new_instructions;
    }
    
    instructions[instruction_count++] = instruction;
  }
  
  // Update block
  block->instructions = instructions;
  block->instruction_count = instruction_count;
  
  return block;
}

/**
 * @brief Parse a function definition or declaration
 * 
 * @param parser Parser instance
 * @return Parsed function or NULL on error
 */
ast_function_t* parser_parse_function(parser_t* parser) {
  // Check for extern
  bool is_extern = false;
  if (check(parser, TOKEN_EXTERN)) {
    advance(parser);
    is_extern = true;
  }
  
  // Expect FUNCTION keyword
  if (!expect(parser, TOKEN_FUNCTION, "Expected 'FUNCTION'")) {
    return NULL;
  }
  
  // Expect function name
  if (!expect(parser, TOKEN_IDENTIFIER, "Expected function name")) {
    return NULL;
  }
  
  const char* function_name = parser->previous_token.identifier_value;
  
  // Expect opening parenthesis
  if (!expect(parser, TOKEN_LPAREN, "Expected '(' after function name")) {
    return NULL;
  }
  
  // Parse parameters
  size_t param_count = 0;
  size_t param_capacity = 8;
  ast_parameter_t* parameters = (ast_parameter_t*)malloc(param_capacity * sizeof(ast_parameter_t));
  if (parameters == NULL) {
    error_report(ERROR_MEMORY, "Failed to allocate memory for parameters");
    return NULL;
  }
  
  bool is_vararg = false;
  
  if (!check(parser, TOKEN_RPAREN)) {
    // At least one parameter
    bool first_param = true;
    
    while (true) {
      if (!first_param) {
        if (!expect(parser, TOKEN_COMMA, "Expected ',' between parameters")) {
          for (size_t i = 0; i < param_count; i++) {
            free((void*)parameters[i].name);
            ast_type_destroy(parameters[i].type);
          }
          free(parameters);
          return NULL;
        }
        
        // Check for varargs
        if (check(parser, TOKEN_DOT)) {
          advance(parser);
          
          if (!expect(parser, TOKEN_DOT, "Expected second '.' for varargs")) {
            for (size_t i = 0; i < param_count; i++) {
              free((void*)parameters[i].name);
              ast_type_destroy(parameters[i].type);
            }
            free(parameters);
            return NULL;
          }
          
          if (!expect(parser, TOKEN_DOT, "Expected third '.' for varargs")) {
            for (size_t i = 0; i < param_count; i++) {
              free((void*)parameters[i].name);
              ast_type_destroy(parameters[i].type);
            }
            free(parameters);
            return NULL;
          }
          
          is_vararg = true;
          break;
        }
      }
      
      // Parse parameter name
      if (!expect(parser, TOKEN_IDENTIFIER, "Expected parameter name")) {
        for (size_t i = 0; i < param_count; i++) {
          free((void*)parameters[i].name);
          ast_type_destroy(parameters[i].type);
        }
        free(parameters);
        return NULL;
      }
      
      const char* param_name = parser->previous_token.identifier_value;
      
      // Expect colon
      if (!expect(parser, TOKEN_COLON, "Expected ':' after parameter name")) {
        for (size_t i = 0; i < param_count; i++) {
          free((void*)parameters[i].name);
          ast_type_destroy(parameters[i].type);
        }
        free(parameters);
        return NULL;
      }
      
      // Parse parameter type
      ast_type_t* param_type = parser_parse_type(parser);
      if (param_type == NULL) {
        for (size_t i = 0; i < param_count; i++) {
          free((void*)parameters[i].name);
          ast_type_destroy(parameters[i].type);
        }
        free(parameters);
        return NULL;
      }
      
      // Add parameter to array
      if (param_count >= param_capacity) {
        param_capacity *= 2;
        ast_parameter_t* new_params = (ast_parameter_t*)realloc(parameters, param_capacity * sizeof(ast_parameter_t));
        if (new_params == NULL) {
          error_report(ERROR_MEMORY, "Failed to resize parameter array");
          for (size_t i = 0; i < param_count; i++) {
            free((void*)parameters[i].name);
            ast_type_destroy(parameters[i].type);
          }
          free(parameters);
          ast_type_destroy(param_type);
          return NULL;
        }
        parameters = new_params;
      }
      
      parameters[param_count].name = strdup(param_name);
      if (parameters[param_count].name == NULL) {
        error_report(ERROR_MEMORY, "Failed to allocate memory for parameter name");
        for (size_t i = 0; i < param_count; i++) {
          free((void*)parameters[i].name);
          ast_type_destroy(parameters[i].type);
        }
        free(parameters);
        ast_type_destroy(param_type);
        return NULL;
      }
      
      parameters[param_count].type = param_type;
      param_count++;
      
      first_param = false;
      
      // Check for closing parenthesis
      if (check(parser, TOKEN_RPAREN)) {
        break;
      }
    }
  }
  
  // Expect closing parenthesis
  if (!expect(parser, TOKEN_RPAREN, "Expected ')' after parameters")) {
    for (size_t i = 0; i < param_count; i++) {
      free((void*)parameters[i].name);
      ast_type_destroy(parameters[i].type);
    }
    free(parameters);
    return NULL;
  }
  
  // Expect arrow
  if (!expect(parser, TOKEN_ARROW, "Expected '->' after parameters")) {
    for (size_t i = 0; i < param_count; i++) {
      free((void*)parameters[i].name);
      ast_type_destroy(parameters[i].type);
    }
    free(parameters);
    return NULL;
  }
  
  // Parse return type
  ast_type_t* return_type = parser_parse_type(parser);
  if (return_type == NULL) {
    for (size_t i = 0; i < param_count; i++) {
      free((void*)parameters[i].name);
      ast_type_destroy(parameters[i].type);
    }
    free(parameters);
    return NULL;
  }
  
  // Create function
  ast_function_t* function = ast_function_create(function_name, return_type, is_extern);
  if (function == NULL) {
    for (size_t i = 0; i < param_count; i++) {
      free((void*)parameters[i].name);
      ast_type_destroy(parameters[i].type);
    }
    free(parameters);
    ast_type_destroy(return_type);
    return NULL;
  }
  
  // Set parameters
  function->parameters = parameters;
  function->parameter_count = param_count;
  function->is_vararg = is_vararg;
  
  // Add to symbol table
  if (!symbol_table_add_function(parser->symbols, function_name, function, parser_line(parser), parser_column(parser))) {
    syntax_error(parser, "Function '%s' already defined", function_name);
    for (size_t i = 0; i < param_count; i++) {
      free((void*)parameters[i].name);
      ast_type_destroy(parameters[i].type);
    }
    free(parameters);
    ast_function_destroy(function);
    return NULL;
  }
  
  // Set current function
  parser->current_function = function;
  
  // Parse target (if any)
  if (check(parser, TOKEN_TARGET)) {
    function->target = parser_parse_target(parser);
    if (function->target == NULL) {
      ast_function_destroy(function);
      return NULL;
    }
  }
  
  // External functions don't have bodies
  if (is_extern) {
    // Expect semicolon
    if (!expect(parser, TOKEN_SEMICOLON, "Expected ';' after external function declaration")) {
      ast_function_destroy(function);
      return NULL;
    }
    
    return function;
  }
  
  // Enter function scope
  symbol_table_enter_scope(parser->symbols);
  
  // Add parameters to symbol table
  for (uint32_t i = 0; i < function->parameter_count; i++) {
    if (!symbol_table_add_parameter(parser->symbols, function->parameters[i].name, 
                                   &function->parameters[i], parser_line(parser), parser_column(parser))) {
      syntax_error(parser, "Parameter '%s' already defined", function->parameters[i].name);
      ast_function_destroy(function);
      return NULL;
    }
  }
  
  // Expect opening brace
  if (!expect(parser, TOKEN_LBRACE, "Expected '{' after function signature")) {
    ast_function_destroy(function);
    return NULL;
  }
  
  // Parse basic blocks
  size_t block_count = 0;
  size_t block_capacity = 8;
  ast_basic_block_t** blocks = (ast_basic_block_t**)malloc(block_capacity * sizeof(ast_basic_block_t*));
  if (blocks == NULL) {
    error_report(ERROR_MEMORY, "Failed to allocate memory for basic blocks");
    ast_function_destroy(function);
    return NULL;
  }
  
  bool has_entry_block = false;
  
  while (!check(parser, TOKEN_RBRACE) && !check(parser, TOKEN_EOF)) {
    // Parse a basic block
    ast_basic_block_t* block = parse_basic_block(parser);
    if (block == NULL) {
      for (size_t i = 0; i < block_count; i++) {
        ast_basic_block_destroy(blocks[i]);
      }
      free(blocks);
      ast_function_destroy(function);
      return NULL;
    }
    
    // Check for entry block
    if (block->is_entry) {
      if (has_entry_block) {
        syntax_error(parser, "Function can only have one ENTRY block");
        ast_basic_block_destroy(block);
        for (size_t i = 0; i < block_count; i++) {
          ast_basic_block_destroy(blocks[i]);
        }
        free(blocks);
        ast_function_destroy(function);
        return NULL;
      }
      has_entry_block = true;
    }
    
    // Add block to function
    if (block_count >= block_capacity) {
      block_capacity *= 2;
      ast_basic_block_t** new_blocks = (ast_basic_block_t**)realloc(blocks, block_capacity * sizeof(ast_basic_block_t*));
      if (new_blocks == NULL) {
        error_report(ERROR_MEMORY, "Failed to resize block array");
        ast_basic_block_destroy(block);
        for (size_t i = 0; i < block_count; i++) {
          ast_basic_block_destroy(blocks[i]);
        }
        free(blocks);
        ast_function_destroy(function);
        return NULL;
      }
      blocks = new_blocks;
    }
    
    blocks[block_count++] = block;
  }
  
  // Expect closing brace
  if (!expect(parser, TOKEN_RBRACE, "Expected '}' after function body")) {
    for (size_t i = 0; i < block_count; i++) {
      ast_basic_block_destroy(blocks[i]);
    }
    free(blocks);
    ast_function_destroy(function);
    return NULL;
  }
  
  // Check for entry block
  if (!has_entry_block) {
    syntax_error(parser, "Function must have an ENTRY block");
    for (size_t i = 0; i < block_count; i++) {
      ast_basic_block_destroy(blocks[i]);
    }
    free(blocks);
    ast_function_destroy(function);
    return NULL;
  }
  
  // Update function
  function->blocks = blocks;
  function->block_count = block_count;
  
  // Exit function scope
  symbol_table_exit_scope(parser->symbols);
  
  return function;
}

/**
 * @brief Parse a complete module from HOIL source
 * 
 * @param parser The parser instance
 * @return Parsed module or NULL on error
 */
ast_module_t* parser_parse_module(parser_t* parser) {
  // Expect MODULE keyword
  if (!expect(parser, TOKEN_MODULE, "Expected 'MODULE'")) {
    return NULL;
  }
  
  // Expect module name
  if (!expect(parser, TOKEN_STRING, "Expected module name string")) {
    return NULL;
  }
  
  const char* module_name = parser->previous_token.string_value;
  
  // Expect semicolon
  if (!expect(parser, TOKEN_SEMICOLON, "Expected ';' after module name")) {
    return NULL;
  }
  
  // Create module
  ast_module_t* module = ast_module_create(module_name);
  if (module == NULL) {
    return NULL;
  }
  
  // Parse target specification if present
  if (check(parser, TOKEN_TARGET)) {
    module->target = parser_parse_target(parser);
    if (module->target == NULL) {
      ast_module_destroy(module);
      return NULL;
    }
  }
  
  // Prepare arrays for module components
  size_t type_capacity = 8;
  size_t constant_capacity = 8;
  size_t global_capacity = 8;
  size_t function_capacity = 8;
  
  module->types = (ast_type_def_t**)malloc(type_capacity * sizeof(ast_type_def_t*));
  module->constants = (ast_constant_t**)malloc(constant_capacity * sizeof(ast_constant_t*));
  module->globals = (ast_global_t**)malloc(global_capacity * sizeof(ast_global_t*));
  module->functions = (ast_function_t**)malloc(function_capacity * sizeof(ast_function_t*));
  
  if (module->types == NULL || module->constants == NULL || 
      module->globals == NULL || module->functions == NULL) {
    error_report(ERROR_MEMORY, "Failed to allocate memory for module components");
    ast_module_destroy(module);
    return NULL;
  }
  
  // Parse module components
  while (!check(parser, TOKEN_EOF)) {
    if (check(parser, TOKEN_TYPE)) {
      // Parse type definition
      ast_type_def_t* type_def = parser_parse_type_def(parser);
      if (type_def == NULL) {
        ast_module_destroy(module);
        return NULL;
      }
      
      // Add to module
      if (module->type_count >= type_capacity) {
        type_capacity *= 2;
        ast_type_def_t** new_types = (ast_type_def_t**)realloc(module->types, type_capacity * sizeof(ast_type_def_t*));
        if (new_types == NULL) {
          error_report(ERROR_MEMORY, "Failed to resize types array");
          ast_module_destroy(module);
          return NULL;
        }
        module->types = new_types;
      }
      
      module->types[module->type_count++] = type_def;
    } else if (check(parser, TOKEN_CONSTANT)) {
      // Parse constant
      ast_constant_t* constant = parser_parse_constant(parser);
      if (constant == NULL) {
        ast_module_destroy(module);
        return NULL;
      }
      
      // Add to module
      if (module->constant_count >= constant_capacity) {
        constant_capacity *= 2;
        ast_constant_t** new_constants = (ast_constant_t**)realloc(module->constants, constant_capacity * sizeof(ast_constant_t*));
        if (new_constants == NULL) {
          error_report(ERROR_MEMORY, "Failed to resize constants array");
          ast_module_destroy(module);
          return NULL;
        }
        module->constants = new_constants;
      }
      
      module->constants[module->constant_count++] = constant;
    } else if (check(parser, TOKEN_GLOBAL)) {
      // Parse global variable
      ast_global_t* global = parser_parse_global(parser);
      if (global == NULL) {
        ast_module_destroy(module);
        return NULL;
      }
      
      // Add to module
      if (module->global_count >= global_capacity) {
        global_capacity *= 2;
        ast_global_t** new_globals = (ast_global_t**)realloc(module->globals, global_capacity * sizeof(ast_global_t*));
        if (new_globals == NULL) {
          error_report(ERROR_MEMORY, "Failed to resize globals array");
          ast_module_destroy(module);
          return NULL;
        }
        module->globals = new_globals;
      }
      
      module->globals[module->global_count++] = global;
    } else if (check(parser, TOKEN_FUNCTION) || check(parser, TOKEN_EXTERN)) {
      // Parse function
      ast_function_t* function = parser_parse_function(parser);
      if (function == NULL) {
        ast_module_destroy(module);
        return NULL;
      }
      
      // Add to module
      if (module->function_count >= function_capacity) {
        function_capacity *= 2;
        ast_function_t** new_functions = (ast_function_t**)realloc(module->functions, function_capacity * sizeof(ast_function_t*));
        if (new_functions == NULL) {
          error_report(ERROR_MEMORY, "Failed to resize functions array");
          ast_module_destroy(module);
          return NULL;
        }
        module->functions = new_functions;
      }
      
      module->functions[module->function_count++] = function;
    } else {
      // Unexpected token
      syntax_error(parser, "Unexpected token, expected module component");
      ast_module_destroy(module);
      return NULL;
    }
  }
  
  return module;
}