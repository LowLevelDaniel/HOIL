/**
 * @file type_system.c
 * @brief Implementation of type system for HOIL compiler
 * 
 * This file implements type operations, comparisons, and validations
 * used during compilation.
 *
 * @author Generated by Claude
 * @date 2025-03-13
 */

#include "type_system.h"
#include "error_handling.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>

/**
 * @brief Initialize the type system
 * 
 * @return true if successful, false otherwise
 */
bool type_system_init(void) {
  // Nothing to initialize at the moment
  return true;
}

/**
 * @brief Clean up the type system
 */
void type_system_cleanup(void) {
  // Nothing to clean up at the moment
}

/**
 * @brief Check if a type is integer (signed or unsigned)
 * 
 * @param type Type to check
 * @return true if integer, false otherwise
 */
bool type_is_integer(const ast_type_t* type) {
  return type != NULL && type->category == TYPE_INTEGER;
}

/**
 * @brief Check if a type is a floating-point type
 * 
 * @param type Type to check
 * @return true if floating-point, false otherwise
 */
bool type_is_float(const ast_type_t* type) {
  return type != NULL && type->category == TYPE_FLOAT;
}

/**
 * @brief Check if a type is numeric (integer or float)
 * 
 * @param type Type to check
 * @return true if numeric, false otherwise
 */
bool type_is_numeric(const ast_type_t* type) {
  return type_is_integer(type) || type_is_float(type);
}

/**
 * @brief Check if a type is a boolean
 * 
 * @param type Type to check
 * @return true if boolean, false otherwise
 */
bool type_is_boolean(const ast_type_t* type) {
  return type != NULL && type->category == TYPE_BOOLEAN;
}

/**
 * @brief Check if a type is a pointer
 * 
 * @param type Type to check
 * @return true if pointer, false otherwise
 */
bool type_is_pointer(const ast_type_t* type) {
  return type != NULL && type->category == TYPE_POINTER;
}

/**
 * @brief Check if a type is a vector
 * 
 * @param type Type to check
 * @return true if vector, false otherwise
 */
bool type_is_vector(const ast_type_t* type) {
  return type != NULL && type->category == TYPE_VECTOR;
}

/**
 * @brief Check if a type is an array
 * 
 * @param type Type to check
 * @return true if array, false otherwise
 */
bool type_is_array(const ast_type_t* type) {
  return type != NULL && type->category == TYPE_ARRAY;
}

/**
 * @brief Check if a type is a structure
 * 
 * @param type Type to check
 * @return true if structure, false otherwise
 */
bool type_is_struct(const ast_type_t* type) {
  return type != NULL && type->category == TYPE_STRUCTURE;
}

/**
 * @brief Check if a type is a function
 * 
 * @param type Type to check
 * @return true if function, false otherwise
 */
bool type_is_function(const ast_type_t* type) {
  return type != NULL && type->category == TYPE_FUNCTION;
}

/**
 * @brief Check if a type is void
 * 
 * @param type Type to check
 * @return true if void, false otherwise
 */
bool type_is_void(const ast_type_t* type) {
  return type != NULL && type->category == TYPE_VOID;
}

/**
 * @brief Compare two structure types for equality
 * 
 * @param type1 First structure type
 * @param type2 Second structure type
 * @return true if equal, false otherwise
 */
static bool struct_types_are_equal(const ast_type_t* type1, const ast_type_t* type2) {
  assert(type1->category == TYPE_STRUCTURE);
  assert(type2->category == TYPE_STRUCTURE);
  
  // If both have definitions, compare definitions
  if (type1->structure.def != NULL && type2->structure.def != NULL) {
    // Same definition means same type
    if (type1->structure.def == type2->structure.def) {
      return true;
    }
    
    // Compare structure layout
    if (type1->structure.def->field_count != type2->structure.def->field_count) {
      return false;
    }
    
    for (uint32_t i = 0; i < type1->structure.def->field_count; i++) {
      // Compare field types
      if (!types_are_equal(type1->structure.def->fields[i].type, 
                          type2->structure.def->fields[i].type)) {
        return false;
      }
      
      // Compare field offsets
      if (type1->structure.def->fields[i].offset != type2->structure.def->fields[i].offset) {
        return false;
      }
    }
    
    return true;
  }
  
  // If definitions are missing, compare names
  if (type1->structure.name != NULL && type2->structure.name != NULL) {
    return strcmp(type1->structure.name, type2->structure.name) == 0;
  }
  
  return false;
}

/**
 * @brief Compare two function types for equality
 * 
 * @param type1 First function type
 * @param type2 Second function type
 * @return true if equal, false otherwise
 */
static bool function_types_are_equal(const ast_type_t* type1, const ast_type_t* type2) {
  assert(type1->category == TYPE_FUNCTION);
  assert(type2->category == TYPE_FUNCTION);
  
  // Compare return types
  if (!types_are_equal(type1->function.return_type, type2->function.return_type)) {
    return false;
  }
  
  // Compare parameter counts and variadic flag
  if (type1->function.param_count != type2->function.param_count ||
      type1->function.is_vararg != type2->function.is_vararg) {
    return false;
  }
  
  // Compare parameter types
  for (uint32_t i = 0; i < type1->function.param_count; i++) {
    if (!types_are_equal(type1->function.param_types[i], type2->function.param_types[i])) {
      return false;
    }
  }
  
  return true;
}

/**
 * @brief Check if two types are exactly equal
 * 
 * @param type1 First type
 * @param type2 Second type
 * @return true if equal, false otherwise
 */
bool types_are_equal(const ast_type_t* type1, const ast_type_t* type2) {
  // Handle NULL cases
  if (type1 == NULL || type2 == NULL) {
    return type1 == type2;
  }
  
  // Different categories means different types
  if (type1->category != type2->category) {
    return false;
  }
  
  // Different qualifiers means different types
  if (type1->qualifier_flags != type2->qualifier_flags) {
    return false;
  }
  
  // Compare based on category
  switch (type1->category) {
    case TYPE_VOID:
    case TYPE_BOOLEAN:
      // Void and boolean are equal if they have the same category
      return true;
      
    case TYPE_INTEGER:
      // Integer types must have same bit width and signedness
      return type1->integer.bit_width == type2->integer.bit_width &&
             type1->integer.is_unsigned == type2->integer.is_unsigned;
      
    case TYPE_FLOAT:
      // Float types must have same bit width
      return type1->float_type.bit_width == type2->float_type.bit_width;
      
    case TYPE_POINTER:
      // Pointer types must have same memory space and element type
      return type1->pointer.space == type2->pointer.space &&
             types_are_equal(type1->pointer.element_type, type2->pointer.element_type);
      
    case TYPE_VECTOR:
      // Vector types must have same element count and element type
      return type1->vector.element_count == type2->vector.element_count &&
             types_are_equal(type1->vector.element_type, type2->vector.element_type);
      
    case TYPE_ARRAY:
      // Array types must have same element count and element type
      return type1->array.element_count == type2->array.element_count &&
             types_are_equal(type1->array.element_type, type2->array.element_type);
      
    case TYPE_STRUCTURE:
      return struct_types_are_equal(type1, type2);
      
    case TYPE_FUNCTION:
      return function_types_are_equal(type1, type2);
      
    default:
      return false;
  }
}

/**
 * @brief Check if two types are compatible (can be assigned)
 * 
 * @param dest Destination type
 * @param source Source type
 * @return true if compatible, false otherwise
 */
bool types_are_compatible(const ast_type_t* dest, const ast_type_t* source) {
  // Exact equality means compatible
  if (types_are_equal(dest, source)) {
    return true;
  }
  
  // Handle NULL cases
  if (dest == NULL || source == NULL) {
    return false;
  }
  
  // Void is not compatible with anything else
  if (dest->category == TYPE_VOID || source->category == TYPE_VOID) {
    return false;
  }
  
  // Numeric type compatibility
  if (type_is_numeric(dest) && type_is_numeric(source)) {
    // Allow numeric conversions with potential precision loss
    return true;
  }
  
  // Boolean can be converted to/from integer
  if ((dest->category == TYPE_BOOLEAN && type_is_integer(source)) ||
      (type_is_integer(dest) && source->category == TYPE_BOOLEAN)) {
    return true;
  }
  
  // Pointer compatibility
  if (dest->category == TYPE_POINTER && source->category == TYPE_POINTER) {
    // Void pointers are compatible with any other pointer type
    if (dest->pointer.element_type->category == TYPE_VOID ||
        source->pointer.element_type->category == TYPE_VOID) {
      return true;
    }
    
    // Otherwise check element type compatibility
    return types_are_compatible(dest->pointer.element_type, source->pointer.element_type);
  }
  
  // Array to pointer decay
  if (dest->category == TYPE_POINTER && source->category == TYPE_ARRAY) {
    return types_are_compatible(dest->pointer.element_type, source->array.element_type);
  }
  
  // Vector type compatibility
  if (dest->category == TYPE_VECTOR && source->category == TYPE_VECTOR) {
    // Must have same element count
    if (dest->vector.element_count != source->vector.element_count) {
      return false;
    }
    
    // Element types must be compatible
    return types_are_compatible(dest->vector.element_type, source->vector.element_type);
  }
  
  // Scalar to vector conversion (splat)
  if (dest->category == TYPE_VECTOR && type_is_numeric(source)) {
    return type_is_numeric(dest->vector.element_type) &&
           types_are_compatible(dest->vector.element_type, source);
  }
  
  // By default, types are not compatible
  return false;
}

/**
 * @brief Check if a type needs conversion to be compatible with another
 * 
 * @param dest Destination type
 * @param source Source type
 * @return true if conversion needed, false otherwise
 */
bool type_needs_conversion(const ast_type_t* dest, const ast_type_t* source) {
  // If types are equal, no conversion needed
  if (types_are_equal(dest, source)) {
    return false;
  }
  
  // If types are compatible, conversion is needed
  return types_are_compatible(dest, source);
}

/**
 * @brief Get the common type between two types (for binary operations)
 * 
 * @param type1 First operand type
 * @param type2 Second operand type
 * @return Common type or NULL if incompatible
 */
ast_type_t* get_common_type(const ast_type_t* type1, const ast_type_t* type2) {
  // Handle NULL cases
  if (type1 == NULL || type2 == NULL) {
    return NULL;
  }
  
  // If types are equal, return a copy of either type
  if (types_are_equal(type1, type2)) {
    ast_type_t* result = (ast_type_t*)malloc(sizeof(ast_type_t));
    if (result == NULL) {
      error_report(ERROR_MEMORY, "Failed to allocate memory for common type");
      return NULL;
    }
    
    memcpy(result, type1, sizeof(ast_type_t));
    return result;
  }
  
  // Handle numeric types
  if (type_is_numeric(type1) && type_is_numeric(type2)) {
    // If either is float, result is float with highest precision
    if (type_is_float(type1) || type_is_float(type2)) {
      uint32_t max_width = 0;
      
      if (type_is_float(type1)) {
        max_width = type1->float_type.bit_width;
      }
      
      if (type_is_float(type2)) {
        max_width = (type2->float_type.bit_width > max_width) ? 
                    type2->float_type.bit_width : max_width;
      }
      
      return ast_type_create_float(max_width);
    }
    
    // Both are integers, use largest width and signedness if either is signed
    uint32_t max_width = (type1->integer.bit_width > type2->integer.bit_width) ? 
                         type1->integer.bit_width : type2->integer.bit_width;
    
    bool is_unsigned = type1->integer.is_unsigned && type2->integer.is_unsigned;
    
    return ast_type_create_integer(max_width, is_unsigned);
  }
  
  // Vector types with compatible element types
  if (type_is_vector(type1) && type_is_vector(type2) &&
      type1->vector.element_count == type2->vector.element_count) {
    
    ast_type_t* common_element = get_common_type(type1->vector.element_type, 
                                               type2->vector.element_type);
    
    if (common_element != NULL) {
      ast_type_t* result = ast_type_create_vector(common_element, type1->vector.element_count);
      ast_type_destroy(common_element);
      return result;
    }
  }
  
  // Pointer types where one is a void pointer
  if (type_is_pointer(type1) && type_is_pointer(type2)) {
    if (type1->pointer.element_type->category == TYPE_VOID) {
      // Type2 wins
      ast_type_t* result = (ast_type_t*)malloc(sizeof(ast_type_t));
      if (result == NULL) {
        error_report(ERROR_MEMORY, "Failed to allocate memory for common type");
        return NULL;
      }
      
      memcpy(result, type2, sizeof(ast_type_t));
      return result;
    }
    
    if (type2->pointer.element_type->category == TYPE_VOID) {
      // Type1 wins
      ast_type_t* result = (ast_type_t*)malloc(sizeof(ast_type_t));
      if (result == NULL) {
        error_report(ERROR_MEMORY, "Failed to allocate memory for common type");
        return NULL;
      }
      
      memcpy(result, type1, sizeof(ast_type_t));
      return result;
    }
  }
  
  // Types are incompatible
  return NULL;
}

/**
 * @brief Get the result type of a binary operation
 * 
 * @param opcode Operation code
 * @param type1 First operand type
 * @param type2 Second operand type
 * @return Result type or NULL if operation invalid for types
 */
ast_type_t* get_binary_op_result_type(opcode_t opcode, const ast_type_t* type1, const ast_type_t* type2) {
  // Handle NULL cases
  if (type1 == NULL || type2 == NULL) {
    return NULL;
  }
  
  // Arithmetic operations
  if (opcode == OPCODE_ADD || opcode == OPCODE_SUB || 
      opcode == OPCODE_MUL || opcode == OPCODE_DIV || 
      opcode == OPCODE_REM) {
    
    // For numeric types, result is common type
    if (type_is_numeric(type1) && type_is_numeric(type2)) {
      return get_common_type(type1, type2);
    }
    
    // Pointer arithmetic for ADD and SUB
    if ((opcode == OPCODE_ADD || opcode == OPCODE_SUB) && 
        type_is_pointer(type1) && type_is_integer(type2)) {
      // Result is same pointer type
      ast_type_t* result = (ast_type_t*)malloc(sizeof(ast_type_t));
      if (result == NULL) {
        error_report(ERROR_MEMORY, "Failed to allocate memory for result type");
        return NULL;
      }
      
      memcpy(result, type1, sizeof(ast_type_t));
      return result;
    }
    
    // SUB between pointers gives integer
    if (opcode == OPCODE_SUB && type_is_pointer(type1) && type_is_pointer(type2)) {
      return ast_type_create_integer(64, false);  // Result is 64-bit signed integer
    }
    
    // Vector operations
    if (type_is_vector(type1) && type_is_vector(type2) &&
        type1->vector.element_count == type2->vector.element_count) {
      
      ast_type_t* element_result = get_binary_op_result_type(opcode, 
                                                          type1->vector.element_type, 
                                                          type2->vector.element_type);
      
      if (element_result != NULL) {
        ast_type_t* result = ast_type_create_vector(element_result, type1->vector.element_count);
        ast_type_destroy(element_result);
        return result;
      }
    }
  }
  
  // Bitwise operations
  if (opcode == OPCODE_AND || opcode == OPCODE_OR || opcode == OPCODE_XOR) {
    // Integer types
    if (type_is_integer(type1) && type_is_integer(type2)) {
      return get_common_type(type1, type2);
    }
    
    // Boolean types
    if (type_is_boolean(type1) && type_is_boolean(type2)) {
      return ast_type_create(TYPE_BOOLEAN);
    }
  }
  
  // Shift operations
  if (opcode == OPCODE_SHL || opcode == OPCODE_SHR) {
    // Left operand must be integer, right operand must be integer
    if (type_is_integer(type1) && type_is_integer(type2)) {
      // Result type is same as left operand
      ast_type_t* result = (ast_type_t*)malloc(sizeof(ast_type_t));
      if (result == NULL) {
        error_report(ERROR_MEMORY, "Failed to allocate memory for result type");
        return NULL;
      }
      
      memcpy(result, type1, sizeof(ast_type_t));
      return result;
    }
  }
  
  // Comparison operations
  if (opcode == OPCODE_CMP_EQ || opcode == OPCODE_CMP_NE ||
      opcode == OPCODE_CMP_LT || opcode == OPCODE_CMP_LE ||
      opcode == OPCODE_CMP_GT || opcode == OPCODE_CMP_GE) {
    
    // Check if types are comparable
    if (types_are_compatible(type1, type2) || types_are_compatible(type2, type1)) {
      // Result is always boolean
      return ast_type_create(TYPE_BOOLEAN);
    }
  }
  
  // Invalid operation for types
  return NULL;
}

/**
 * @brief Get the result type of a unary operation
 * 
 * @param opcode Operation code
 * @param type Operand type
 * @return Result type or NULL if operation invalid for type
 */
ast_type_t* get_unary_op_result_type(opcode_t opcode, const ast_type_t* type) {
  // Handle NULL case
  if (type == NULL) {
    return NULL;
  }
  
  // Numeric negation
  if (opcode == OPCODE_NEG) {
    if (type_is_numeric(type)) {
      // Make sure integer result is signed
      if (type_is_integer(type) && type->integer.is_unsigned) {
        return ast_type_create_integer(type->integer.bit_width, false);
      } else {
        // For other numeric types, result is same type
        ast_type_t* result = (ast_type_t*)malloc(sizeof(ast_type_t));
        if (result == NULL) {
          error_report(ERROR_MEMORY, "Failed to allocate memory for result type");
          return NULL;
        }
        
        memcpy(result, type, sizeof(ast_type_t));
        return result;
      }
    }
  }
  
  // Bitwise NOT
  if (opcode == OPCODE_NOT) {
    if (type_is_integer(type)) {
      // Result is same type
      ast_type_t* result = (ast_type_t*)malloc(sizeof(ast_type_t));
      if (result == NULL) {
        error_report(ERROR_MEMORY, "Failed to allocate memory for result type");
        return NULL;
      }
      
      memcpy(result, type, sizeof(ast_type_t));
      return result;
    }
    
    if (type_is_boolean(type)) {
      return ast_type_create(TYPE_BOOLEAN);
    }
  }
  
  // Load operation
  if (opcode == OPCODE_LOAD) {
    if (type_is_pointer(type)) {
      // Result is the pointed-to type
      ast_type_t* result = (ast_type_t*)malloc(sizeof(ast_type_t));
      if (result == NULL) {
        error_report(ERROR_MEMORY, "Failed to allocate memory for result type");
        return NULL;
      }
      
      memcpy(result, type->pointer.element_type, sizeof(ast_type_t));
      return result;
    }
  }
  
  // Load effective address
  if (opcode == OPCODE_LEA) {
    if (type_is_array(type)) {
      // Result is pointer to element type
      return ast_type_create_pointer(type->array.element_type, MEMORY_DEFAULT);
    }
  }
  
  // Vector load
  if (opcode == OPCODE_VLOAD) {
    if (type_is_pointer(type) && type->pointer.element_type != NULL) {
      // Result is vector of element type
      return ast_type_create_vector(type->pointer.element_type, 4);  // Default to 4 elements
    }
  }
  
  // Invalid operation for type
  return NULL;
}

/**
 * @brief Get a string representation of a type
 * 
 * @param type Type to convert
 * @return String representation (caller must free) or NULL on error
 */
char* type_to_string(const ast_type_t* type) {
  if (type == NULL) {
    return strdup("NULL");
  }
  
  char buffer[256];
  
  switch (type->category) {
    case TYPE_VOID:
      return strdup("void");
      
    case TYPE_BOOLEAN:
      return strdup("bool");
      
    case TYPE_INTEGER:
      snprintf(buffer, sizeof(buffer), "%s%u", 
               type->integer.is_unsigned ? "u" : "i", 
               type->integer.bit_width);
      return strdup(buffer);
      
    case TYPE_FLOAT:
      snprintf(buffer, sizeof(buffer), "f%u", type->float_type.bit_width);
      return strdup(buffer);
      
    case TYPE_POINTER:
      {
        char* element_str = type_to_string(type->pointer.element_type);
        if (element_str == NULL) {
          return NULL;
        }
        
        const char* space_str = "";
        switch (type->pointer.space) {
          case MEMORY_GLOBAL: space_str = ", global"; break;
          case MEMORY_LOCAL: space_str = ", local"; break;
          case MEMORY_SHARED: space_str = ", shared"; break;
          case MEMORY_CONSTANT: space_str = ", constant"; break;
          case MEMORY_PRIVATE: space_str = ", private"; break;
          default: space_str = ""; break;
        }
        
        snprintf(buffer, sizeof(buffer), "ptr<%s%s>", element_str, space_str);
        free(element_str);
        return strdup(buffer);
      }
      
    case TYPE_VECTOR:
      {
        char* element_str = type_to_string(type->vector.element_type);
        if (element_str == NULL) {
          return NULL;
        }
        
        snprintf(buffer, sizeof(buffer), "vec<%s, %u>", 
                element_str, type->vector.element_count);
        free(element_str);
        return strdup(buffer);
      }
      
    case TYPE_ARRAY:
      {
        char* element_str = type_to_string(type->array.element_type);
        if (element_str == NULL) {
          return NULL;
        }
        
        if (type->array.element_count > 0) {
          snprintf(buffer, sizeof(buffer), "array<%s, %u>", 
                  element_str, type->array.element_count);
        } else {
          snprintf(buffer, sizeof(buffer), "array<%s>", element_str);
        }
        
        free(element_str);
        return strdup(buffer);
      }
      
    case TYPE_STRUCTURE:
      if (type->structure.name != NULL) {
        return strdup(type->structure.name);
      } else {
        return strdup("<anonymous-struct>");
      }
      
    case TYPE_FUNCTION:
      {
        char* return_str = type_to_string(type->function.return_type);
        if (return_str == NULL) {
          return NULL;
        }
        
        // Start with function(
        char* result = strdup("function(");
        if (result == NULL) {
          free(return_str);
          return NULL;
        }
        
        // Add parameter types
        for (uint32_t i = 0; i < type->function.param_count; i++) {
          char* param_str = type_to_string(type->function.param_types[i]);
          if (param_str == NULL) {
            free(return_str);
            free(result);
            return NULL;
          }
          
          // Add separator if not first parameter
          if (i > 0) {
            char* new_result = realloc(result, strlen(result) + 2 + strlen(param_str) + 1);
            if (new_result == NULL) {
              free(return_str);
              free(result);
              free(param_str);
              return NULL;
            }
            result = new_result;
            strcat(result, ", ");
          } else {
            char* new_result = realloc(result, strlen(result) + strlen(param_str) + 1);
            if (new_result == NULL) {
              free(return_str);
              free(result);
              free(param_str);
              return NULL;
            }
            result = new_result;
          }
          
          strcat(result, param_str);
          free(param_str);
        }
        
        // Add variadic indicator if needed
        if (type->function.is_vararg) {
          char* new_result = realloc(result, strlen(result) + 5 + 1);
          if (new_result == NULL) {
            free(return_str);
            free(result);
            return NULL;
          }
          result = new_result;
          
          if (type->function.param_count > 0) {
            strcat(result, ", ...");
          } else {
            strcat(result, "...");
          }
        }
        
        // Add closing parenthesis and return type
        char* new_result = realloc(result, strlen(result) + 4 + strlen(return_str) + 1);
        if (new_result == NULL) {
          free(return_str);
          free(result);
          return NULL;
        }
        result = new_result;
        
        strcat(result, ") -> ");
        strcat(result, return_str);
        free(return_str);
        
        return result;
      }
      
    default:
      return strdup("<unknown-type>");
  }
}

/**
 * @brief Validate a constant value against a type
 * 
 * @param constant Constant to validate
 * @param type Expected type
 * @return true if valid, false otherwise
 */
bool validate_constant_type(const ast_constant_t* constant, const ast_type_t* type) {
  if (constant == NULL || type == NULL) {
    return false;
  }
  
  switch (constant->value_type) {
    case CONSTANT_INTEGER:
      // Integer constants can be assigned to integer, float, or boolean types
      if (type_is_integer(type) || type_is_float(type) || type_is_boolean(type)) {
        return true;
      }
      break;
      
    case CONSTANT_FLOAT:
      // Float constants can be assigned to float types
      if (type_is_float(type)) {
        return true;
      }
      break;
      
    case CONSTANT_BOOLEAN:
      // Boolean constants can be assigned to boolean or integer types
      if (type_is_boolean(type) || type_is_integer(type)) {
        return true;
      }
      break;
      
    case CONSTANT_STRING:
      // String constants can be assigned to character arrays
      if (type_is_array(type) && 
          type->array.element_type != NULL &&
          type_is_integer(type->array.element_type) &&
          type->array.element_type->integer.bit_width == 8) {
        
        // Check array size if known
        if (type->array.element_count > 0) {
          // Add 1 for null terminator
          return strlen(constant->string_value) + 1 <= type->array.element_count;
        }
        
        return true;
      }
      break;
      
    case CONSTANT_ARRAY:
      // Array constants can be assigned to compatible array types
      if (type_is_array(type) && 
          constant->array.element_count <= type->array.element_count) {
        
        // Check each element
        for (uint32_t i = 0; i < constant->array.element_count; i++) {
          if (!validate_constant_type(constant->array.elements[i], type->array.element_type)) {
            return false;
          }
        }
        
        return true;
      }
      break;
      
    case CONSTANT_STRUCT:
      // Structure constants can be assigned to compatible structure types
      if (type_is_struct(type) && 
          type->structure.def != NULL &&
          constant->structure.field_count == type->structure.def->field_count) {
        
        // Check each field
        for (uint32_t i = 0; i < constant->structure.field_count; i++) {
          if (!validate_constant_type(constant->structure.fields[i], 
                                     type->structure.def->fields[i].type)) {
            return false;
          }
        }
        
        return true;
      }
      break;
  }
  
  return false;
}

/**
 * @brief Validate function parameter count and types
 * 
 * @param function Function to validate
 * @param arg_count Number of arguments
 * @param arg_types Array of argument types
 * @param error_msg Buffer to store error message (may be NULL)
 * @param error_msg_size Size of error message buffer
 * @return true if valid, false otherwise
 */
bool validate_function_call(const ast_function_t* function, uint32_t arg_count, 
                           const ast_type_t** arg_types, char* error_msg, size_t error_msg_size) {
  if (function == NULL) {
    if (error_msg != NULL) {
      snprintf(error_msg, error_msg_size, "Function is NULL");
    }
    return false;
  }
  
  // Check argument count
  if (!function->is_vararg && arg_count != function->parameter_count) {
    if (error_msg != NULL) {
      snprintf(error_msg, error_msg_size, 
               "Function expects %u arguments, but got %u", 
               function->parameter_count, arg_count);
    }
    return false;
  }
  
  if (function->is_vararg && arg_count < function->parameter_count) {
    if (error_msg != NULL) {
      snprintf(error_msg, error_msg_size, 
               "Function expects at least %u arguments, but got %u", 
               function->parameter_count, arg_count);
    }
    return false;
  }
  
  // Check argument types
  for (uint32_t i = 0; i < function->parameter_count && i < arg_count; i++) {
    if (!types_are_compatible(function->parameters[i].type, arg_types[i])) {
      if (error_msg != NULL) {
        char* param_type_str = type_to_string(function->parameters[i].type);
        char* arg_type_str = type_to_string(arg_types[i]);
        
        snprintf(error_msg, error_msg_size, 
                "Incompatible argument %u: expected %s, got %s", 
                i, param_type_str, arg_type_str);
        
        free(param_type_str);
        free(arg_type_str);
      }
      return false;
    }
  }
  
  return true;
}