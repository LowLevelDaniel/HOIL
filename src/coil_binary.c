/**
 * @file coil_binary.c
 * @brief Implementation of COIL binary format generator
 * 
 * This file implements the generation of COIL binary format from
 * AST representation of HOIL code.
 *
 * @author Generated by Claude
 * @date 2025-03-13
 */

#include "coil_binary.h"
#include "error_handling.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>

/**
 * @brief Initial buffer capacity for COIL binary
 */
#define INITIAL_BUFFER_CAPACITY 4096

/**
 * @brief COIL binary file header structure
 */
typedef struct {
  uint32_t magic;           /**< Magic number ("COIL" in ASCII) */
  uint32_t version;         /**< Version information */
  uint32_t section_count;   /**< Number of sections */
  uint32_t flags;           /**< Module flags */
} coil_header_t;

/**
 * @brief COIL section header structure
 */
typedef struct {
  uint32_t type;            /**< Section type */
  uint32_t offset;          /**< Byte offset from start of file */
  uint32_t size;            /**< Size of section in bytes */
} coil_section_header_t;

/**
 * @brief Section builder structure
 */
typedef struct {
  uint8_t* data;            /**< Section data buffer */
  size_t size;              /**< Current size of section data */
  size_t capacity;          /**< Capacity of section data buffer */
  section_type_t type;      /**< Section type */
} section_builder_t;

/**
 * @brief Create a new section builder
 * 
 * @param type Section type
 * @return New section builder or NULL on error
 */
static section_builder_t* section_builder_create(section_type_t type) {
  section_builder_t* builder = (section_builder_t*)malloc(sizeof(section_builder_t));
  if (builder == NULL) {
    error_report(ERROR_MEMORY, "Failed to allocate memory for section builder");
    return NULL;
  }
  
  builder->capacity = 256;  // Start with a small buffer
  builder->data = (uint8_t*)malloc(builder->capacity);
  if (builder->data == NULL) {
    error_report(ERROR_MEMORY, "Failed to allocate memory for section data");
    free(builder);
    return NULL;
  }
  
  builder->size = 0;
  builder->type = type;
  
  return builder;
}

/**
 * @brief Destroy a section builder and free resources
 * 
 * @param builder Builder to destroy
 */
static void section_builder_destroy(section_builder_t* builder) {
  if (builder == NULL) {
    return;
  }
  
  free(builder->data);
  free(builder);
}

/**
 * @brief Ensure the section buffer has enough capacity
 * 
 * @param builder Section builder
 * @param additional_size Additional size needed
 * @return true if successful, false on error
 */
static bool section_builder_ensure_capacity(section_builder_t* builder, size_t additional_size) {
  if (builder->size + additional_size <= builder->capacity) {
    return true;  // Already enough capacity
  }
  
  // Calculate new capacity (double current capacity until sufficient)
  size_t new_capacity = builder->capacity;
  while (new_capacity < builder->size + additional_size) {
    new_capacity *= 2;
  }
  
  // Reallocate buffer
  uint8_t* new_data = (uint8_t*)realloc(builder->data, new_capacity);
  if (new_data == NULL) {
    error_report(ERROR_MEMORY, "Failed to resize section data buffer");
    return false;
  }
  
  builder->data = new_data;
  builder->capacity = new_capacity;
  
  return true;
}

/**
 * @brief Write 8-bit value to section
 * 
 * @param builder Section builder
 * @param value Value to write
 * @return true if successful, false on error
 */
static bool section_write_u8(section_builder_t* builder, uint8_t value) {
  if (!section_builder_ensure_capacity(builder, 1)) {
    return false;
  }
  
  builder->data[builder->size++] = value;
  return true;
}

/**
 * @brief Write 16-bit value to section
 * 
 * @param builder Section builder
 * @param value Value to write
 * @return true if successful, false on error
 */
static bool section_write_u16(section_builder_t* builder, uint16_t value) {
  if (!section_builder_ensure_capacity(builder, 2)) {
    return false;
  }
  
  // Little-endian encoding
  builder->data[builder->size++] = (uint8_t)(value & 0xFF);
  builder->data[builder->size++] = (uint8_t)((value >> 8) & 0xFF);
  
  return true;
}

/**
 * @brief Write 32-bit value to section
 * 
 * @param builder Section builder
 * @param value Value to write
 * @return true if successful, false on error
 */
static bool section_write_u32(section_builder_t* builder, uint32_t value) {
  if (!section_builder_ensure_capacity(builder, 4)) {
    return false;
  }
  
  // Little-endian encoding
  builder->data[builder->size++] = (uint8_t)(value & 0xFF);
  builder->data[builder->size++] = (uint8_t)((value >> 8) & 0xFF);
  builder->data[builder->size++] = (uint8_t)((value >> 16) & 0xFF);
  builder->data[builder->size++] = (uint8_t)((value >> 24) & 0xFF);
  
  return true;
}

/**
 * @brief Write 64-bit value to section
 * 
 * @param builder Section builder
 * @param value Value to write
 * @return true if successful, false on error
 */
static bool section_write_u64(section_builder_t* builder, uint64_t value) {
  if (!section_builder_ensure_capacity(builder, 8)) {
    return false;
  }
  
  // Little-endian encoding
  builder->data[builder->size++] = (uint8_t)(value & 0xFF);
  builder->data[builder->size++] = (uint8_t)((value >> 8) & 0xFF);
  builder->data[builder->size++] = (uint8_t)((value >> 16) & 0xFF);
  builder->data[builder->size++] = (uint8_t)((value >> 24) & 0xFF);
  builder->data[builder->size++] = (uint8_t)((value >> 32) & 0xFF);
  builder->data[builder->size++] = (uint8_t)((value >> 40) & 0xFF);
  builder->data[builder->size++] = (uint8_t)((value >> 48) & 0xFF);
  builder->data[builder->size++] = (uint8_t)((value >> 56) & 0xFF);
  
  return true;
}

/**
 * @brief Write string to section
 * 
 * @param builder Section builder
 * @param str String to write
 * @return true if successful, false on error
 */
static bool section_write_string(section_builder_t* builder, const char* str) {
  if (str == NULL) {
    // Write empty string
    return section_write_u16(builder, 0);
  }
  
  size_t length = strlen(str);
  if (length > UINT16_MAX) {
    error_report(ERROR_CODEGEN, "String too long for COIL binary format");
    return false;
  }
  
  if (!section_write_u16(builder, (uint16_t)length)) {
    return false;
  }
  
  if (!section_builder_ensure_capacity(builder, length)) {
    return false;
  }
  
  memcpy(builder->data + builder->size, str, length);
  builder->size += length;
  
  return true;
}

/**
 * @brief Write raw data to section
 * 
 * @param builder Section builder
 * @param data Data to write
 * @param size Size of data in bytes
 * @return true if successful, false on error
 */
static bool section_write_data(section_builder_t* builder, const void* data, size_t size) {
  if (data == NULL || size == 0) {
    return true;  // Nothing to write
  }
  
  if (!section_builder_ensure_capacity(builder, size)) {
    return false;
  }
  
  memcpy(builder->data + builder->size, data, size);
  builder->size += size;
  
  return true;
}

/**
 * @brief Initialize a new COIL binary buffer
 * 
 * @return New COIL binary or NULL on error
 */
static coil_binary_t* coil_binary_create(void) {
  coil_binary_t* binary = (coil_binary_t*)malloc(sizeof(coil_binary_t));
  if (binary == NULL) {
    error_report(ERROR_MEMORY, "Failed to allocate memory for COIL binary");
    return NULL;
  }
  
  binary->capacity = INITIAL_BUFFER_CAPACITY;
  binary->data = (uint8_t*)malloc(binary->capacity);
  if (binary->data == NULL) {
    error_report(ERROR_MEMORY, "Failed to allocate memory for COIL binary data");
    free(binary);
    return NULL;
  }
  
  binary->size = 0;
  
  return binary;
}

/**
 * @brief Encode a COIL type
 * 
 * @param type AST type to encode
 * @return 32-bit type encoding
 */
uint32_t coil_encode_type(const ast_type_t* type) {
  if (type == NULL) {
    return 0;  // Invalid type
  }
  
  uint32_t encoding = 0;
  
  // Encode category (4 bits)
  encoding |= (uint32_t)type->category & 0xF;
  
  // Encode width (8 bits)
  switch (type->category) {
    case TYPE_INTEGER:
      encoding |= ((uint32_t)type->integer.bit_width & 0xFF) << 4;
      break;
      
    case TYPE_FLOAT:
      encoding |= ((uint32_t)type->float_type.bit_width & 0xFF) << 4;
      break;
      
    case TYPE_POINTER:
      // For pointers, use default width of 64 bits
      encoding |= (64 & 0xFF) << 4;
      break;
      
    case TYPE_VECTOR:
      // For vectors, encode element count in width field
      encoding |= ((uint32_t)type->vector.element_count & 0xFF) << 4;
      break;
      
    case TYPE_ARRAY:
      // For arrays, we don't encode element count in the type encoding
      break;
      
    default:
      // Other types don't have width information
      break;
  }
  
  // Encode qualifiers (8 bits)
  encoding |= (type->qualifier_flags & 0xFF) << 12;
  
  // Encode attributes (12 bits) - reserved for future use
  
  return encoding;
}

/**
 * @brief Decode a COIL type
 * 
 * @param encoded Encoded 32-bit type
 * @return Decoded AST type or NULL on error
 */
ast_type_t* coil_decode_type(uint32_t encoded) {
  // Extract category (4 bits)
  type_category_t category = (type_category_t)(encoded & 0xF);
  
  // Create basic type
  ast_type_t* type = ast_type_create(category);
  if (type == NULL) {
    return NULL;
  }
  
  // Extract width (8 bits)
  uint32_t width = (encoded >> 4) & 0xFF;
  
  // Extract qualifiers (8 bits)
  type->qualifier_flags = (encoded >> 12) & 0xFF;
  
  // Set type-specific fields
  switch (category) {
    case TYPE_INTEGER:
      type->integer.bit_width = width;
      type->integer.is_unsigned = (type->qualifier_flags & QUALIFIER_UNSIGNED) != 0;
      break;
      
    case TYPE_FLOAT:
      type->float_type.bit_width = width;
      break;
      
    case TYPE_POINTER:
      // Width is ignored for pointers
      // Element type would need to be filled in by the caller
      break;
      
    case TYPE_VECTOR:
      type->vector.element_count = width;
      // Element type would need to be filled in by the caller
      break;
      
    default:
      // Other types don't use width information
      break;
  }
  
  return type;
}

/**
 * @brief Get the size of a type in bytes
 * 
 * @param type Type to check
 * @return Size in bytes
 */
uint32_t coil_type_size(const ast_type_t* type) {
  if (type == NULL) {
    return 0;
  }
  
  switch (type->category) {
    case TYPE_VOID:
      return 0;
      
    case TYPE_BOOLEAN:
      return 1;  // 1 byte for boolean
      
    case TYPE_INTEGER:
      return type->integer.bit_width / 8;
      
    case TYPE_FLOAT:
      return type->float_type.bit_width / 8;
      
    case TYPE_POINTER:
      return 8;  // 64-bit pointers
      
    case TYPE_VECTOR:
      if (type->vector.element_type == NULL) {
        return 0;
      }
      return coil_type_size(type->vector.element_type) * type->vector.element_count;
      
    case TYPE_ARRAY:
      if (type->array.element_type == NULL) {
        return 0;
      }
      return coil_type_size(type->array.element_type) * type->array.element_count;
      
    case TYPE_STRUCTURE:
      if (type->structure.def == NULL) {
        return 0;
      }
      return type->structure.def->size;
      
    case TYPE_FUNCTION:
      return 0;  // Functions don't have a size
      
    default:
      return 0;
  }
}

/**
 * @brief Get the alignment of a type in bytes
 * 
 * @param type Type to check
 * @return Alignment in bytes
 */
uint32_t coil_type_alignment(const ast_type_t* type) {
  if (type == NULL) {
    return 0;
  }
  
  switch (type->category) {
    case TYPE_VOID:
      return 0;
      
    case TYPE_BOOLEAN:
      return 1;  // 1 byte alignment for boolean
      
    case TYPE_INTEGER:
      return type->integer.bit_width / 8;  // Natural alignment
      
    case TYPE_FLOAT:
      return type->float_type.bit_width / 8;  // Natural alignment
      
    case TYPE_POINTER:
      return 8;  // 8 byte alignment for pointers
      
    case TYPE_VECTOR:
      // Vector alignment is typically the alignment of the entire vector
      if (type->vector.element_type == NULL) {
        return 0;
      }
      return coil_type_size(type->vector.element_type) * type->vector.element_count;
      
    case TYPE_ARRAY:
      if (type->array.element_type == NULL) {
        return 0;
      }
      return coil_type_alignment(type->array.element_type);
      
    case TYPE_STRUCTURE:
      if (type->structure.def == NULL) {
        return 0;
      }
      return type->structure.def->alignment;
      
    case TYPE_FUNCTION:
      return 0;  // Functions don't have alignment
      
    default:
      return 0;
  }
}

/**
 * @brief Write a type to a section
 * 
 * @param builder Section builder
 * @param type Type to write
 * @return true if successful, false on error
 */
static bool write_type(section_builder_t* builder, const ast_type_t* type) {
  if (type == NULL) {
    return section_write_u32(builder, 0);  // Write null type
  }
  
  uint32_t encoding = coil_encode_type(type);
  if (!section_write_u32(builder, encoding)) {
    return false;
  }
  
  // Write additional type information based on category
  switch (type->category) {
    case TYPE_POINTER:
      if (!write_type(builder, type->pointer.element_type)) {
        return false;
      }
      // Write memory space
      if (!section_write_u8(builder, (uint8_t)type->pointer.space)) {
        return false;
      }
      break;
      
    case TYPE_VECTOR:
      if (!write_type(builder, type->vector.element_type)) {
        return false;
      }
      break;
      
    case TYPE_ARRAY:
      if (!write_type(builder, type->array.element_type)) {
        return false;
      }
      if (!section_write_u32(builder, type->array.element_count)) {
        return false;
      }
      break;
      
    case TYPE_STRUCTURE:
      if (!section_write_string(builder, type->structure.name)) {
        return false;
      }
      break;
      
    case TYPE_FUNCTION:
      if (!write_type(builder, type->function.return_type)) {
        return false;
      }
      if (!section_write_u16(builder, (uint16_t)type->function.param_count)) {
        return false;
      }
      if (!section_write_u8(builder, type->function.is_vararg ? 1 : 0)) {
        return false;
      }
      for (uint32_t i = 0; i < type->function.param_count; i++) {
        if (!write_type(builder, type->function.param_types[i])) {
          return false;
        }
      }
      break;
      
    default:
      // Other types don't need additional information
      break;
  }
  
  return true;
}

/**
 * @brief Generate the type section
 * 
 * @param module AST module
 * @return Type section builder or NULL on error
 */
static section_builder_t* generate_type_section(ast_module_t* module) {
  section_builder_t* builder = section_builder_create(SECTION_TYPE);
  if (builder == NULL) {
    return NULL;
  }
  
  // Write the number of type definitions
  if (!section_write_u32(builder, module->type_count)) {
    section_builder_destroy(builder);
    return NULL;
  }
  
  // Write each type definition
  for (uint32_t i = 0; i < module->type_count; i++) {
    ast_type_def_t* type_def = module->types[i];
    
    // Write type name
    if (!section_write_string(builder, type_def->name)) {
      section_builder_destroy(builder);
      return NULL;
    }
    
    // Write basic type info
    if (!write_type(builder, &type_def->type)) {
      section_builder_destroy(builder);
      return NULL;
    }
    
    // Handle structure types specially
    if (type_def->type.category == TYPE_STRUCTURE) {
      // Write field count
      if (!section_write_u16(builder, (uint16_t)type_def->field_count)) {
        section_builder_destroy(builder);
        return NULL;
      }
      
      // Write structure size and alignment
      if (!section_write_u32(builder, type_def->size)) {
        section_builder_destroy(builder);
        return NULL;
      }
      
      if (!section_write_u32(builder, type_def->alignment)) {
        section_builder_destroy(builder);
        return NULL;
      }
      
      // Write each field
      for (uint32_t j = 0; j < type_def->field_count; j++) {
        // Write field name
        if (!section_write_string(builder, type_def->fields[j].name)) {
          section_builder_destroy(builder);
          return NULL;
        }
        
        // Write field type
        if (!write_type(builder, type_def->fields[j].type)) {
          section_builder_destroy(builder);
          return NULL;
        }
        
        // Write field offset
        if (!section_write_u32(builder, type_def->fields[j].offset)) {
          section_builder_destroy(builder);
          return NULL;
        }
      }
    }
  }
  
  return builder;
}

/**
 * @brief Write a constant value to a section
 * 
 * @param builder Section builder
 * @param constant Constant to write
 * @return true if successful, false on error
 */
static bool write_constant_value(section_builder_t* builder, const ast_constant_t* constant) {
  if (constant == NULL) {
    return false;
  }
  
  // Write value type
  if (!section_write_u8(builder, (uint8_t)constant->value_type)) {
    return false;
  }
  
  // Write value based on type
  switch (constant->value_type) {
    case CONSTANT_INTEGER:
      if (!section_write_u64(builder, (uint64_t)constant->int_value)) {
        return false;
      }
      break;
      
    case CONSTANT_FLOAT:
      {
        // Convert double to 64-bit binary representation
        uint64_t bits;
        memcpy(&bits, &constant->float_value, sizeof(bits));
        if (!section_write_u64(builder, bits)) {
          return false;
        }
      }
      break;
      
    case CONSTANT_BOOLEAN:
      if (!section_write_u8(builder, constant->bool_value ? 1 : 0)) {
        return false;
      }
      break;
      
    case CONSTANT_STRING:
      if (!section_write_string(builder, constant->string_value)) {
        return false;
      }
      break;
      
    case CONSTANT_ARRAY:
      // Write element count
      if (!section_write_u32(builder, constant->array.element_count)) {
        return false;
      }
      
      // Write each element
      for (uint32_t i = 0; i < constant->array.element_count; i++) {
        if (!write_constant_value(builder, constant->array.elements[i])) {
          return false;
        }
      }
      break;
      
    case CONSTANT_STRUCT:
      // Write field count
      if (!section_write_u32(builder, constant->structure.field_count)) {
        return false;
      }
      
      // Write each field
      for (uint32_t i = 0; i < constant->structure.field_count; i++) {
        if (!write_constant_value(builder, constant->structure.fields[i])) {
          return false;
        }
      }
      break;
  }
  
  return true;
}

/**
 * @brief Generate the constant section
 * 
 * @param module AST module
 * @return Constant section builder or NULL on error
 */
static section_builder_t* generate_constant_section(ast_module_t* module) {
  section_builder_t* builder = section_builder_create(SECTION_CONSTANT);
  if (builder == NULL) {
    return NULL;
  }
  
  // Write the number of constants
  if (!section_write_u32(builder, module->constant_count)) {
    section_builder_destroy(builder);
    return NULL;
  }
  
  // Write each constant
  for (uint32_t i = 0; i < module->constant_count; i++) {
    ast_constant_t* constant = module->constants[i];
    
    // Write constant name
    if (!section_write_string(builder, constant->name)) {
      section_builder_destroy(builder);
      return NULL;
    }
    
    // Write constant type
    if (!write_type(builder, constant->type)) {
      section_builder_destroy(builder);
      return NULL;
    }
    
    // Write constant value
    if (!write_constant_value(builder, constant)) {
      section_builder_destroy(builder);
      return NULL;
    }
  }
  
  return builder;
}

/**
 * @brief Generate the global section
 * 
 * @param module AST module
 * @return Global section builder or NULL on error
 */
static section_builder_t* generate_global_section(ast_module_t* module) {
  section_builder_t* builder = section_builder_create(SECTION_GLOBAL);
  if (builder == NULL) {
    return NULL;
  }
  
  // Write the number of globals
  if (!section_write_u32(builder, module->global_count)) {
    section_builder_destroy(builder);
    return NULL;
  }
  
  // Write each global
  for (uint32_t i = 0; i < module->global_count; i++) {
    ast_global_t* global = module->globals[i];
    
    // Write global name
    if (!section_write_string(builder, global->name)) {
      section_builder_destroy(builder);
      return NULL;
    }
    
    // Write global type
    if (!write_type(builder, global->type)) {
      section_builder_destroy(builder);
      return NULL;
    }
    
    // Write whether global has initializer
    if (!section_write_u8(builder, global->has_initializer ? 1 : 0)) {
      section_builder_destroy(builder);
      return NULL;
    }
    
    // Write initializer if present
    if (global->has_initializer) {
      if (!write_constant_value(builder, global->initializer)) {
        section_builder_destroy(builder);
        return NULL;
      }
    }
  }
  
  return builder;
}

/**
 * @brief Generate the function section (declarations only)
 * 
 * @param module AST module
 * @return Function section builder or NULL on error
 */
static section_builder_t* generate_function_section(ast_module_t* module) {
  section_builder_t* builder = section_builder_create(SECTION_FUNCTION);
  if (builder == NULL) {
    return NULL;
  }
  
  // Write the number of functions
  if (!section_write_u32(builder, module->function_count)) {
    section_builder_destroy(builder);
    return NULL;
  }
  
  // Write each function declaration
  for (uint32_t i = 0; i < module->function_count; i++) {
    ast_function_t* function = module->functions[i];
    
    // Write function name
    if (!section_write_string(builder, function->name)) {
      section_builder_destroy(builder);
      return NULL;
    }
    
    // Write function return type
    if (!write_type(builder, function->return_type)) {
      section_builder_destroy(builder);
      return NULL;
    }
    
    // Write parameter count
    if (!section_write_u16(builder, (uint16_t)function->parameter_count)) {
      section_builder_destroy(builder);
      return NULL;
    }
    
    // Write whether function is variadic
    if (!section_write_u8(builder, function->is_vararg ? 1 : 0)) {
      section_builder_destroy(builder);
      return NULL;
    }
    
    // Write whether function is external
    if (!section_write_u8(builder, function->is_extern ? 1 : 0)) {
      section_builder_destroy(builder);
      return NULL;
    }
    
    // Write each parameter
    for (uint32_t j = 0; j < function->parameter_count; j++) {
      // Write parameter name
      if (!section_write_string(builder, function->parameters[j].name)) {
        section_builder_destroy(builder);
        return NULL;
      }
      
      // Write parameter type
      if (!write_type(builder, function->parameters[j].type)) {
        section_builder_destroy(builder);
        return NULL;
      }
    }
    
    // Write target if present
    if (function->target != NULL) {
      if (!section_write_u8(builder, 1)) {  // Has target
        section_builder_destroy(builder);
        return NULL;
      }
      
      // Write device class
      if (!section_write_string(builder, function->target->device_class)) {
        section_builder_destroy(builder);
        return NULL;
      }
      
      // Write required features
      if (!section_write_u16(builder, (uint16_t)function->target->required_count)) {
        section_builder_destroy(builder);
        return NULL;
      }
      
      for (uint32_t j = 0; j < function->target->required_count; j++) {
        if (!section_write_string(builder, function->target->required_features[j])) {
          section_builder_destroy(builder);
          return NULL;
        }
      }
      
      // Write preferred features
      if (!section_write_u16(builder, (uint16_t)function->target->preferred_count)) {
        section_builder_destroy(builder);
        return NULL;
      }
      
      for (uint32_t j = 0; j < function->target->preferred_count; j++) {
        if (!section_write_string(builder, function->target->preferred_features[j])) {
          section_builder_destroy(builder);
          return NULL;
        }
      }
    } else {
      if (!section_write_u8(builder, 0)) {  // No target
        section_builder_destroy(builder);
        return NULL;
      }
    }
  }
  
  return builder;
}

/**
 * @brief Write an operand to a section
 * 
 * @param builder Section builder
 * @param operand Operand to write
 * @return true if successful, false on error
 */
static bool write_operand(section_builder_t* builder, const ast_operand_t* operand) {
  if (operand == NULL) {
    // Write null operand
    return section_write_u8(builder, OPERAND_NONE);
  }
  
  // Write operand type
  if (!section_write_u8(builder, (uint8_t)operand->type)) {
    return false;
  }
  
  // Write operand value type
  if (!write_type(builder, operand->value_type)) {
    return false;
  }
  
  // Write operand-specific data
  switch (operand->type) {
    case OPERAND_LOCAL:
    case OPERAND_REGISTER:
      if (!section_write_string(builder, operand->local.name)) {
        return false;
      }
      break;
      
    case OPERAND_GLOBAL:
      if (!section_write_string(builder, operand->global.name)) {
        return false;
      }
      break;
      
    case OPERAND_CONSTANT:
      // For constants, we write the constant value directly
      if (!write_constant_value(builder, operand->constant.constant)) {
        return false;
      }
      break;
      
    case OPERAND_FUNCTION:
      if (!section_write_string(builder, operand->function.name)) {
        return false;
      }
      break;
      
    case OPERAND_BLOCK:
      if (!section_write_string(builder, operand->block.name)) {
        return false;
      }
      break;
      
    default:
      // Nothing extra needed for other operand types
      break;
  }
  
  return true;
}

/**
 * @brief Write an instruction to a section
 * 
 * @param builder Section builder
 * @param instruction Instruction to write
 * @return true if successful, false on error
 */
static bool write_instruction(section_builder_t* builder, const ast_instruction_t* instruction) {
  if (instruction == NULL) {
    return false;
  }
  
  // Write opcode
  if (!section_write_u8(builder, (uint8_t)instruction->opcode)) {
    return false;
  }
  
  // Write whether instruction has a result
  bool has_result = instruction->result != NULL;
  if (!section_write_u8(builder, has_result ? 1 : 0)) {
    return false;
  }
  
  // Write result if present
  if (has_result) {
    if (!write_operand(builder, instruction->result)) {
      return false;
    }
  }
  
  // Write operand count
  if (!section_write_u8(builder, (uint8_t)instruction->operand_count)) {
    return false;
  }
  
  // Write operands
  for (uint32_t i = 0; i < instruction->operand_count; i++) {
    if (!write_operand(builder, instruction->operands[i])) {
      return false;
    }
  }
  
  // Write opcode-specific data
  switch (instruction->opcode) {
    case OPCODE_CALL:
      // Write whether call is to a variadic function
      if (!section_write_u8(builder, instruction->call_info.is_vararg ? 1 : 0)) {
        return false;
      }
      
      // Write return type
      if (!write_type(builder, instruction->call_info.return_type)) {
        return false;
      }
      break;
      
    case OPCODE_BR:
      // Write whether branch is conditional
      if (!section_write_u8(builder, instruction->branch_info.is_conditional ? 1 : 0)) {
        return false;
      }
      
      // Write true branch target
      if (!section_write_string(builder, instruction->branch_info.true_label)) {
        return false;
      }
      
      // Write false branch target if conditional
      if (instruction->branch_info.is_conditional) {
        if (!section_write_string(builder, instruction->branch_info.false_label)) {
          return false;
        }
      }
      break;
      
    case OPCODE_RET:
      // Write whether return has a value
      if (!section_write_u8(builder, instruction->return_info.has_value ? 1 : 0)) {
        return false;
      }
      break;
      
    default:
      // Other opcodes don't need additional data
      break;
  }
  
  return true;
}

/**
 * @brief Generate the code section (function implementations)
 * 
 * @param module AST module
 * @return Code section builder or NULL on error
 */
static section_builder_t* generate_code_section(ast_module_t* module) {
  section_builder_t* builder = section_builder_create(SECTION_CODE);
  if (builder == NULL) {
    return NULL;
  }
  
  // Count non-external functions
  uint32_t implementation_count = 0;
  for (uint32_t i = 0; i < module->function_count; i++) {
    if (!module->functions[i]->is_extern) {
      implementation_count++;
    }
  }
  
  // Write the number of function implementations
  if (!section_write_u32(builder, implementation_count)) {
    section_builder_destroy(builder);
    return NULL;
  }
  
  // Write each function implementation
  for (uint32_t i = 0; i < module->function_count; i++) {
    ast_function_t* function = module->functions[i];
    
    if (function->is_extern) {
      continue;  // Skip external functions
    }
    
    // Write function name
    if (!section_write_string(builder, function->name)) {
      section_builder_destroy(builder);
      return NULL;
    }
    
    // Write block count
    if (!section_write_u16(builder, (uint16_t)function->block_count)) {
      section_builder_destroy(builder);
      return NULL;
    }
    
    // Write each block
    for (uint32_t j = 0; j < function->block_count; j++) {
      ast_basic_block_t* block = function->blocks[j];
      
      // Write block name
      if (!section_write_string(builder, block->name)) {
        section_builder_destroy(builder);
        return NULL;
      }
      
      // Write whether this is the entry block
      if (!section_write_u8(builder, block->is_entry ? 1 : 0)) {
        section_builder_destroy(builder);
        return NULL;
      }
      
      // Write instruction count
      if (!section_write_u16(builder, (uint16_t)block->instruction_count)) {
        section_builder_destroy(builder);
        return NULL;
      }
      
      // Write each instruction
      for (uint32_t k = 0; k < block->instruction_count; k++) {
        if (!write_instruction(builder, block->instructions[k])) {
          section_builder_destroy(builder);
          return NULL;
        }
      }
    }
  }
  
  return builder;
}

/**
 * @brief Generate the metadata section
 * 
 * @param module AST module
 * @return Metadata section builder or NULL on error
 */
static section_builder_t* generate_metadata_section(ast_module_t* module) {
  section_builder_t* builder = section_builder_create(SECTION_METADATA);
  if (builder == NULL) {
    return NULL;
  }
  
  // Write module target if present
  if (module->target != NULL) {
    if (!section_write_u8(builder, 1)) {  // Has target
      section_builder_destroy(builder);
      return NULL;
    }
    
    // Write device class
    if (!section_write_string(builder, module->target->device_class)) {
      section_builder_destroy(builder);
      return NULL;
    }
    
    // Write required features
    if (!section_write_u16(builder, (uint16_t)module->target->required_count)) {
      section_builder_destroy(builder);
      return NULL;
    }
    
    for (uint32_t i = 0; i < module->target->required_count; i++) {
      if (!section_write_string(builder, module->target->required_features[i])) {
        section_builder_destroy(builder);
        return NULL;
      }
    }
    
    // Write preferred features
    if (!section_write_u16(builder, (uint16_t)module->target->preferred_count)) {
      section_builder_destroy(builder);
      return NULL;
    }
    
    for (uint32_t i = 0; i < module->target->preferred_count; i++) {
      if (!section_write_string(builder, module->target->preferred_features[i])) {
        section_builder_destroy(builder);
        return NULL;
      }
    }
  } else {
    if (!section_write_u8(builder, 0)) {  // No target
      section_builder_destroy(builder);
      return NULL;
    }
  }
  
  return builder;
}

/**
 * @brief Combine all sections into a complete COIL binary
 * 
 * @param sections Array of section builders
 * @param section_count Number of sections
 * @return Generated COIL binary or NULL on error
 */
static coil_binary_t* combine_sections(section_builder_t** sections, size_t section_count) {
  coil_binary_t* binary = coil_binary_create();
  if (binary == NULL) {
    return NULL;
  }
  
  // Calculate total size needed
  size_t header_size = sizeof(coil_header_t) + section_count * sizeof(coil_section_header_t);
  size_t total_size = header_size;
  
  for (size_t i = 0; i < section_count; i++) {
    // Align each section on 4-byte boundary
    size_t padding = (4 - (total_size % 4)) % 4;
    total_size += padding;
    total_size += sections[i]->size;
  }
  
  // Ensure capacity
  if (binary->capacity < total_size) {
    uint8_t* new_data = (uint8_t*)realloc(binary->data, total_size);
    if (new_data == NULL) {
      error_report(ERROR_MEMORY, "Failed to allocate memory for COIL binary");
      coil_binary_destroy(binary);
      return NULL;
    }
    
    binary->data = new_data;
    binary->capacity = total_size;
  }
  
  // Write header
  coil_header_t header;
  header.magic = COIL_MAGIC;
  header.version = COIL_VERSION;
  header.section_count = (uint32_t)section_count;
  header.flags = 0;  // No special flags
  
  memcpy(binary->data, &header, sizeof(header));
  binary->size = sizeof(header);
  
  // Write section headers
  size_t data_offset = header_size;
  
  for (size_t i = 0; i < section_count; i++) {
    // Align section data on 4-byte boundary
    size_t padding = (4 - (data_offset % 4)) % 4;
    data_offset += padding;
    
    coil_section_header_t section_header;
    section_header.type = (uint32_t)sections[i]->type;
    section_header.offset = (uint32_t)data_offset;
    section_header.size = (uint32_t)sections[i]->size;
    
    memcpy(binary->data + binary->size, &section_header, sizeof(section_header));
    binary->size += sizeof(section_header);
    
    data_offset += sections[i]->size;
  }
  
  // Write section data
  for (size_t i = 0; i < section_count; i++) {
    // Align section data on 4-byte boundary
    size_t padding = (4 - (binary->size % 4)) % 4;
    memset(binary->data + binary->size, 0, padding);
    binary->size += padding;
    
    memcpy(binary->data + binary->size, sections[i]->data, sections[i]->size);
    binary->size += sections[i]->size;
  }
  
  return binary;
}

/**
 * @brief Generate COIL binary format from AST
 * 
 * @param module AST module to convert
 * @return Generated COIL binary or NULL on error
 */
coil_binary_t* coil_binary_generate(ast_module_t* module) {
  if (module == NULL) {
    error_report(ERROR_INVALID_ARGUMENT, "Module cannot be NULL");
    return NULL;
  }
  
  // Create section builders
  section_builder_t* type_section = generate_type_section(module);
  if (type_section == NULL) {
    return NULL;
  }
  
  section_builder_t* constant_section = generate_constant_section(module);
  if (constant_section == NULL) {
    section_builder_destroy(type_section);
    return NULL;
  }
  
  section_builder_t* global_section = generate_global_section(module);
  if (global_section == NULL) {
    section_builder_destroy(type_section);
    section_builder_destroy(constant_section);
    return NULL;
  }
  
  section_builder_t* function_section = generate_function_section(module);
  if (function_section == NULL) {
    section_builder_destroy(type_section);
    section_builder_destroy(constant_section);
    section_builder_destroy(global_section);
    return NULL;
  }
  
  section_builder_t* code_section = generate_code_section(module);
  if (code_section == NULL) {
    section_builder_destroy(type_section);
    section_builder_destroy(constant_section);
    section_builder_destroy(global_section);
    section_builder_destroy(function_section);
    return NULL;
  }
  
  section_builder_t* metadata_section = generate_metadata_section(module);
  if (metadata_section == NULL) {
    section_builder_destroy(type_section);
    section_builder_destroy(constant_section);
    section_builder_destroy(global_section);
    section_builder_destroy(function_section);
    section_builder_destroy(code_section);
    return NULL;
  }
  
  // Combine all sections into a binary
  section_builder_t* sections[] = {
    type_section,
    constant_section,
    global_section,
    function_section,
    code_section,
    metadata_section
  };
  
  coil_binary_t* binary = combine_sections(sections, sizeof(sections) / sizeof(sections[0]));
  
  // Clean up section builders
  section_builder_destroy(type_section);
  section_builder_destroy(constant_section);
  section_builder_destroy(global_section);
  section_builder_destroy(function_section);
  section_builder_destroy(code_section);
  section_builder_destroy(metadata_section);
  
  if (binary == NULL) {
    return NULL;
  }
  
  return binary;
}

/**
 * @brief Destroy a COIL binary and free resources
 * 
 * @param binary Binary to destroy
 */
void coil_binary_destroy(coil_binary_t* binary) {
  if (binary == NULL) {
    return;
  }
  
  free(binary->data);
  free(binary);
}

/**
 * @brief Write a COIL binary to file
 * 
 * @param binary Binary to write
 * @param filename Output filename
 * @return true if successful, false otherwise
 */
bool coil_binary_write(const coil_binary_t* binary, const char* filename) {
  if (binary == NULL || filename == NULL) {
    error_report(ERROR_INVALID_ARGUMENT, "Invalid argument to coil_binary_write");
    return false;
  }
  
  FILE* file = fopen(filename, "wb");
  if (file == NULL) {
    error_report(ERROR_IO, "Failed to open file for writing: %s", filename);
    return false;
  }
  
  size_t written = fwrite(binary->data, 1, binary->size, file);
  if (written != binary->size) {
    error_report(ERROR_IO, "Failed to write to file: %s", filename);
    fclose(file);
    return false;
  }
  
  fclose(file);
  return true;
}

/**
 * @brief Read a COIL binary from file
 * 
 * @param filename Input filename
 * @return Read binary or NULL on error
 */
coil_binary_t* coil_binary_read(const char* filename) {
  if (filename == NULL) {
    error_report(ERROR_INVALID_ARGUMENT, "Filename cannot be NULL");
    return NULL;
  }
  
  FILE* file = fopen(filename, "rb");
  if (file == NULL) {
    error_report(ERROR_IO, "Failed to open file for reading: %s", filename);
    return NULL;
  }
  
  // Get file size
  fseek(file, 0, SEEK_END);
  long file_size = ftell(file);
  fseek(file, 0, SEEK_SET);
  
  if (file_size <= 0) {
    error_report(ERROR_IO, "Invalid file size: %s", filename);
    fclose(file);
    return NULL;
  }
  
  // Create binary
  coil_binary_t* binary = (coil_binary_t*)malloc(sizeof(coil_binary_t));
  if (binary == NULL) {
    error_report(ERROR_MEMORY, "Failed to allocate memory for COIL binary");
    fclose(file);
    return NULL;
  }
  
  binary->size = (size_t)file_size;
  binary->capacity = (size_t)file_size;
  binary->data = (uint8_t*)malloc(binary->capacity);
  if (binary->data == NULL) {
    error_report(ERROR_MEMORY, "Failed to allocate memory for COIL binary data");
    free(binary);
    fclose(file);
    return NULL;
  }
  
  // Read file content
  size_t read_size = fread(binary->data, 1, binary->size, file);
  if (read_size != binary->size) {
    error_report(ERROR_IO, "Failed to read from file: %s", filename);
    coil_binary_destroy(binary);
    fclose(file);
    return NULL;
  }
  
  fclose(file);
  
  // Validate file header
  if (binary->size < sizeof(coil_header_t)) {
    error_report(ERROR_CODEGEN, "Invalid COIL binary: file too small");
    coil_binary_destroy(binary);
    return NULL;
  }
  
  coil_header_t* header = (coil_header_t*)binary->data;
  if (header->magic != COIL_MAGIC) {
    error_report(ERROR_CODEGEN, "Invalid COIL binary: incorrect magic number");
    coil_binary_destroy(binary);
    return NULL;
  }
  
  return binary;
}