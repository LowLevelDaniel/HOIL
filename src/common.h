/**
 * @file common.h
 * @brief Common definitions for HOIL to COIL compiler
 * 
 * This file provides common utility functions, macros, and types used
 * throughout the HOIL to COIL compiler.
 *
 * @author Generated by Claude
 * @date 2025-03-13
 */

#ifndef COMMON_H
#define COMMON_H

#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <stdint.h>
#include <stdio.h>

/**
 * @brief Version information
 */
#define HOIL2COIL_VERSION_MAJOR 1
#define HOIL2COIL_VERSION_MINOR 0
#define HOIL2COIL_VERSION_PATCH 0

/**
 * @brief String representation of version
 */
#define HOIL2COIL_VERSION_STRING "1.0.0"

/**
 * @brief Safe string duplication
 * 
 * @param str String to duplicate
 * @return Duplicated string or NULL on error
 */
static inline char* safe_strdup(const char* str) {
  if (str == NULL) {
    return NULL;
  }
  
  size_t len = strlen(str);
  char* dup = (char*)malloc(len + 1);
  if (dup == NULL) {
    return NULL;
  }
  
  memcpy(dup, str, len + 1);
  return dup;
}

/**
 * @brief Safe memory allocation with error checking
 * 
 * @param size Size in bytes to allocate
 * @return Allocated memory or NULL on error
 */
static inline void* safe_malloc(size_t size) {
  void* ptr = malloc(size);
  if (ptr == NULL && size > 0) {
    fprintf(stderr, "Error: Memory allocation failed for %zu bytes\n", size);
  }
  return ptr;
}

/**
 * @brief Safe memory reallocation with error checking
 * 
 * @param ptr Pointer to existing memory or NULL
 * @param size New size in bytes
 * @return Reallocated memory or NULL on error
 */
static inline void* safe_realloc(void* ptr, size_t size) {
  void* new_ptr = realloc(ptr, size);
  if (new_ptr == NULL && size > 0) {
    fprintf(stderr, "Error: Memory reallocation failed for %zu bytes\n", size);
  }
  return new_ptr;
}

/**
 * @brief Safe string copy with size checking
 * 
 * @param dest Destination buffer
 * @param src Source string
 * @param size Size of destination buffer
 * @return Destination buffer
 */
static inline char* safe_strcpy(char* dest, const char* src, size_t size) {
  if (dest == NULL || src == NULL || size == 0) {
    return dest;
  }
  
  size_t src_len = strlen(src);
  size_t copy_len = (src_len < size - 1) ? src_len : size - 1;
  
  memcpy(dest, src, copy_len);
  dest[copy_len] = '\0';
  
  return dest;
}

/**
 * @brief Check if a string starts with a prefix
 * 
 * @param str String to check
 * @param prefix Prefix to look for
 * @return true if str starts with prefix, false otherwise
 */
static inline bool str_starts_with(const char* str, const char* prefix) {
  if (str == NULL || prefix == NULL) {
    return false;
  }
  
  return strncmp(str, prefix, strlen(prefix)) == 0;
}

/**
 * @brief Check if a string ends with a suffix
 * 
 * @param str String to check
 * @param suffix Suffix to look for
 * @return true if str ends with suffix, false otherwise
 */
static inline bool str_ends_with(const char* str, const char* suffix) {
  if (str == NULL || suffix == NULL) {
    return false;
  }
  
  size_t str_len = strlen(str);
  size_t suffix_len = strlen(suffix);
  
  if (suffix_len > str_len) {
    return false;
  }
  
  return strcmp(str + str_len - suffix_len, suffix) == 0;
}

/**
 * @brief Replace file extension
 * 
 * @param filename Original filename
 * @param new_ext New extension (with or without dot)
 * @return New filename string (caller must free) or NULL on error
 */
static inline char* replace_extension(const char* filename, const char* new_ext) {
  if (filename == NULL || new_ext == NULL) {
    return NULL;
  }
  
  // Find last dot in filename
  const char* last_dot = strrchr(filename, '.');
  if (last_dot == NULL) {
    // No extension, just append new one
    size_t len = strlen(filename);
    size_t ext_len = strlen(new_ext);
    char* result = (char*)malloc(len + ext_len + 2); // +2 for dot and null terminator
    if (result == NULL) {
      return NULL;
    }
    
    strcpy(result, filename);
    result[len] = '.';
    strcpy(result + len + 1, new_ext);
    
    return result;
  }
  
  // Calculate length of base name
  size_t base_len = last_dot - filename;
  
  // Calculate length of new extension
  size_t ext_len = strlen(new_ext);
  
  // Add dot if not present in new extension
  bool need_dot = new_ext[0] != '.';
  
  // Allocate memory for new filename
  char* result = (char*)malloc(base_len + ext_len + (need_dot ? 2 : 1));
  if (result == NULL) {
    return NULL;
  }
  
  // Copy base name
  memcpy(result, filename, base_len);
  
  // Add dot if needed
  if (need_dot) {
    result[base_len] = '.';
    strcpy(result + base_len + 1, new_ext);
  } else {
    strcpy(result + base_len, new_ext);
  }
  
  return result;
}

/**
 * @brief Make a full path from a directory and filename
 * 
 * @param dir Directory path (may be NULL)
 * @param filename Filename
 * @return Full path (caller must free) or NULL on error
 */
static inline char* make_path(const char* dir, const char* filename) {
  if (filename == NULL) {
    return NULL;
  }
  
  if (dir == NULL || dir[0] == '\0') {
    return safe_strdup(filename);
  }
  
  size_t dir_len = strlen(dir);
  size_t filename_len = strlen(filename);
  
  // Check if directory ends with separator
  bool needs_separator = dir[dir_len - 1] != '/' && dir[dir_len - 1] != '\\';
  
  char* result = (char*)malloc(dir_len + filename_len + (needs_separator ? 2 : 1));
  if (result == NULL) {
    return NULL;
  }
  
  strcpy(result, dir);
  
  if (needs_separator) {
    result[dir_len] = '/';
    strcpy(result + dir_len + 1, filename);
  } else {
    strcpy(result + dir_len, filename);
  }
  
  return result;
}

#endif /* COMMON_H */