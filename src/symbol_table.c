/**
 * @file symbol_table.c
 * @brief Implementation of symbol table for HOIL compiler
 * 
 * This file provides the implementation of the symbol table that tracks
 * identifiers and their associated information during parsing.
 *
 * @author Generated by Claude
 * @date 2025-03-13
 */

#include "symbol_table.h"
#include "error_handling.h"
#include <stdlib.h>
#include <string.h>
#include <assert.h>

/**
 * @brief Maximum number of nested scopes
 */
#define MAX_SCOPES 256

/**
 * @brief Initial size of symbol hash table
 */
#define INITIAL_TABLE_SIZE 64

/**
 * @brief Symbol table entry structure
 */
typedef struct symbol_entry_node_t {
  symbol_entry_t entry;                  /**< Symbol entry data */
  struct symbol_entry_node_t* next;      /**< Next entry in hash chain */
} symbol_entry_node_t;

/**
 * @brief Symbol table structure
 */
struct symbol_table_t {
  symbol_entry_node_t** buckets;         /**< Hash table buckets */
  size_t bucket_count;                   /**< Number of buckets */
  size_t entry_count;                    /**< Total number of entries */
  
  size_t scope_level;                    /**< Current scope level */
  size_t scope_entry_counts[MAX_SCOPES]; /**< Number of entries in each scope */
};

/**
 * @brief Hash a string
 * 
 * @param str String to hash
 * @return Hash value
 */
static size_t hash_string(const char* str) {
  size_t hash = 5381;
  int c;
  
  while ((c = *str++)) {
    hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
  }
  
  return hash;
}

/**
 * @brief Find an entry node in the symbol table
 * 
 * @param table Symbol table
 * @param name Symbol name
 * @param scope_level Maximum scope level to search (0 for current scope only)
 * @return Entry node or NULL if not found
 */
static symbol_entry_node_t* find_entry_node(const symbol_table_t* table, const char* name, size_t scope_level) {
  if (table == NULL || name == NULL) {
    return NULL;
  }
  
  size_t hash = hash_string(name) % table->bucket_count;
  symbol_entry_node_t* node = table->buckets[hash];
  
  while (node != NULL) {
    if (strcmp(node->entry.name, name) == 0) {
      // If scope_level is 0, only match symbols in the current scope
      if (scope_level == 0 && node->entry.scope_level != table->scope_level) {
        node = node->next;
        continue;
      }
      
      // If scope_level is non-zero, only match symbols up to that scope level
      if (scope_level > 0 && node->entry.scope_level > scope_level) {
        node = node->next;
        continue;
      }
      
      return node;
    }
    
    node = node->next;
  }
  
  return NULL;
}

/**
 * @brief Create a new symbol table
 * 
 * @return Pointer to created symbol table or NULL on failure
 */
symbol_table_t* symbol_table_create(void) {
  symbol_table_t* table = (symbol_table_t*)malloc(sizeof(symbol_table_t));
  if (table == NULL) {
    error_report(ERROR_MEMORY, "Failed to allocate memory for symbol table");
    return NULL;
  }
  
  table->bucket_count = INITIAL_TABLE_SIZE;
  table->entry_count = 0;
  table->scope_level = 0;
  
  // Initialize scope entry counts
  for (size_t i = 0; i < MAX_SCOPES; i++) {
    table->scope_entry_counts[i] = 0;
  }
  
  // Allocate buckets
  table->buckets = (symbol_entry_node_t**)calloc(table->bucket_count, sizeof(symbol_entry_node_t*));
  if (table->buckets == NULL) {
    error_report(ERROR_MEMORY, "Failed to allocate memory for symbol table buckets");
    free(table);
    return NULL;
  }
  
  return table;
}

/**
 * @brief Destroy a symbol table and free resources
 * 
 * @param table Symbol table to destroy
 */
void symbol_table_destroy(symbol_table_t* table) {
  if (table == NULL) {
    return;
  }
  
  // Free all entry nodes
  for (size_t i = 0; i < table->bucket_count; i++) {
    symbol_entry_node_t* node = table->buckets[i];
    while (node != NULL) {
      symbol_entry_node_t* next = node->next;
      
      // Free entry name
      free((void*)node->entry.name);
      
      free(node);
      node = next;
    }
  }
  
  free(table->buckets);
  free(table);
}

/**
 * @brief Enter a new scope level
 * 
 * @param table Symbol table
 * @return Current scope level
 */
size_t symbol_table_enter_scope(symbol_table_t* table) {
  if (table == NULL) {
    error_report(ERROR_INVALID_ARGUMENT, "Symbol table cannot be NULL");
    return 0;
  }
  
  if (table->scope_level >= MAX_SCOPES - 1) {
    error_report(ERROR_INTERNAL, "Maximum scope nesting level exceeded");
    return table->scope_level;
  }
  
  table->scope_level++;
  return table->scope_level;
}

/**
 * @brief Exit the current scope level
 * 
 * @param table Symbol table
 * @return New current scope level
 */
size_t symbol_table_exit_scope(symbol_table_t* table) {
  if (table == NULL) {
    error_report(ERROR_INVALID_ARGUMENT, "Symbol table cannot be NULL");
    return 0;
  }
  
  if (table->scope_level == 0) {
    error_report(ERROR_INTERNAL, "Cannot exit global scope");
    return 0;
  }
  
  // Remove all symbols from the current scope
  size_t entries_to_remove = table->scope_entry_counts[table->scope_level];
  if (entries_to_remove > 0) {
    for (size_t i = 0; i < table->bucket_count; i++) {
      symbol_entry_node_t** node_ptr = &table->buckets[i];
      
      while (*node_ptr != NULL) {
        symbol_entry_node_t* node = *node_ptr;
        
        if (node->entry.scope_level == table->scope_level) {
          // Remove this node
          *node_ptr = node->next;
          
          // Free entry name
          free((void*)node->entry.name);
          
          free(node);
          
          // Decrement counters
          table->entry_count--;
          entries_to_remove--;
          
          if (entries_to_remove == 0) {
            break;
          }
        } else {
          // Move to next node
          node_ptr = &node->next;
        }
      }
      
      if (entries_to_remove == 0) {
        break;
      }
    }
  }
  
  // Reset entry count for this scope
  table->scope_entry_counts[table->scope_level] = 0;
  
  // Decrement scope level
  table->scope_level--;
  
  return table->scope_level;
}

/**
 * @brief Get the current scope level
 * 
 * @param table Symbol table
 * @return Current scope level
 */
size_t symbol_table_scope_level(const symbol_table_t* table) {
  if (table == NULL) {
    error_report(ERROR_INVALID_ARGUMENT, "Symbol table cannot be NULL");
    return 0;
  }
  
  return table->scope_level;
}

/**
 * @brief Add entry to symbol table
 * 
 * @param table Symbol table
 * @param name Symbol name
 * @param kind Symbol kind
 * @param data Symbol data
 * @param line Line where defined
 * @param column Column where defined
 * @return true if successful, false if name already exists in the current scope
 */
static bool symbol_table_add_entry(symbol_table_t* table, const char* name, 
                                  symbol_kind_t kind, void* data, 
                                  size_t line, size_t column) {
  if (table == NULL) {
    error_report(ERROR_INVALID_ARGUMENT, "Symbol table cannot be NULL");
    return false;
  }
  
  if (name == NULL) {
    error_report(ERROR_INVALID_ARGUMENT, "Symbol name cannot be NULL");
    return false;
  }
  
  // Check if the symbol already exists in the current scope
  symbol_entry_node_t* existing = find_entry_node(table, name, 0);
  if (existing != NULL) {
    error_report(ERROR_SEMANTIC, "Symbol '%s' already defined at line %zu", 
                name, existing->entry.line);
    return false;
  }
  
  // Create a new entry node
  symbol_entry_node_t* node = (symbol_entry_node_t*)malloc(sizeof(symbol_entry_node_t));
  if (node == NULL) {
    error_report(ERROR_MEMORY, "Failed to allocate memory for symbol table entry");
    return false;
  }
  
  // Initialize the entry
  node->entry.name = strdup(name);
  if (node->entry.name == NULL) {
    error_report(ERROR_MEMORY, "Failed to allocate memory for symbol name");
    free(node);
    return false;
  }
  
  node->entry.kind = kind;
  node->entry.scope_level = table->scope_level;
  node->entry.line = line;
  node->entry.column = column;
  
  // Set the appropriate union field based on kind
  switch (kind) {
    case SYMBOL_TYPE:
      node->entry.type_def = (ast_type_def_t*)data;
      break;
      
    case SYMBOL_CONSTANT:
      node->entry.constant = (ast_constant_t*)data;
      break;
      
    case SYMBOL_GLOBAL:
      node->entry.global = (ast_global_t*)data;
      break;
      
    case SYMBOL_FUNCTION:
      node->entry.function = (ast_function_t*)data;
      break;
      
    case SYMBOL_PARAMETER:
      node->entry.parameter = (ast_parameter_t*)data;
      break;
      
    case SYMBOL_LOCAL:
      node->entry.local = (ast_operand_t*)data;
      break;
      
    case SYMBOL_BLOCK:
      node->entry.block = (ast_basic_block_t*)data;
      break;
  }
  
  // Add to the hash table
  size_t hash = hash_string(name) % table->bucket_count;
  node->next = table->buckets[hash];
  table->buckets[hash] = node;
  
  // Update counters
  table->entry_count++;
  table->scope_entry_counts[table->scope_level]++;
  
  return true;
}

/**
 * @brief Add a type definition to the symbol table
 * 
 * @param table Symbol table
 * @param name Type name
 * @param type_def Type definition
 * @param line Line where defined
 * @param column Column where defined
 * @return true if successful, false if name already exists in the current scope
 */
bool symbol_table_add_type(symbol_table_t* table, const char* name, 
                           ast_type_def_t* type_def, size_t line, size_t column) {
  return symbol_table_add_entry(table, name, SYMBOL_TYPE, type_def, line, column);
}

/**
 * @brief Add a constant to the symbol table
 * 
 * @param table Symbol table
 * @param name Constant name
 * @param constant Constant definition
 * @param line Line where defined
 * @param column Column where defined
 * @return true if successful, false if name already exists in the current scope
 */
bool symbol_table_add_constant(symbol_table_t* table, const char* name, 
                               ast_constant_t* constant, size_t line, size_t column) {
  return symbol_table_add_entry(table, name, SYMBOL_CONSTANT, constant, line, column);
}

/**
 * @brief Add a global variable to the symbol table
 * 
 * @param table Symbol table
 * @param name Global name
 * @param global Global definition
 * @param line Line where defined
 * @param column Column where defined
 * @return true if successful, false if name already exists in the current scope
 */
bool symbol_table_add_global(symbol_table_t* table, const char* name, 
                             ast_global_t* global, size_t line, size_t column) {
  return symbol_table_add_entry(table, name, SYMBOL_GLOBAL, global, line, column);
}

/**
 * @brief Add a function to the symbol table
 * 
 * @param table Symbol table
 * @param name Function name
 * @param function Function definition
 * @param line Line where defined
 * @param column Column where defined
 * @return true if successful, false if name already exists in the current scope
 */
bool symbol_table_add_function(symbol_table_t* table, const char* name, 
                               ast_function_t* function, size_t line, size_t column) {
  return symbol_table_add_entry(table, name, SYMBOL_FUNCTION, function, line, column);
}

/**
 * @brief Add a function parameter to the symbol table
 * 
 * @param table Symbol table
 * @param name Parameter name
 * @param parameter Parameter definition
 * @param line Line where defined
 * @param column Column where defined
 * @return true if successful, false if name already exists in the current scope
 */
bool symbol_table_add_parameter(symbol_table_t* table, const char* name, 
                                ast_parameter_t* parameter, size_t line, size_t column) {
  return symbol_table_add_entry(table, name, SYMBOL_PARAMETER, parameter, line, column);
}

/**
 * @brief Add a local variable to the symbol table
 * 
 * @param table Symbol table
 * @param name Local variable name
 * @param local Local variable
 * @param line Line where defined
 * @param column Column where defined
 * @return true if successful, false if name already exists in the current scope
 */
bool symbol_table_add_local(symbol_table_t* table, const char* name, 
                            ast_operand_t* local, size_t line, size_t column) {
  return symbol_table_add_entry(table, name, SYMBOL_LOCAL, local, line, column);
}

/**
 * @brief Add a basic block to the symbol table
 * 
 * @param table Symbol table
 * @param name Block name
 * @param block Basic block
 * @param line Line where defined
 * @param column Column where defined
 * @return true if successful, false if name already exists in the current scope
 */
bool symbol_table_add_block(symbol_table_t* table, const char* name, 
                            ast_basic_block_t* block, size_t line, size_t column) {
  return symbol_table_add_entry(table, name, SYMBOL_BLOCK, block, line, column);
}

/**
 * @brief Lookup a symbol by name
 * 
 * @param table Symbol table
 * @param name Symbol name
 * @return Symbol entry or NULL if not found
 */
const symbol_entry_t* symbol_table_lookup(const symbol_table_t* table, const char* name) {
  symbol_entry_node_t* node = find_entry_node(table, name, table->scope_level);
  
  if (node == NULL) {
    return NULL;
  }
  
  return &node->entry;
}

/**
 * @brief Lookup a type by name
 * 
 * @param table Symbol table
 * @param name Type name
 * @return Type definition or NULL if not found
 */
ast_type_def_t* symbol_table_lookup_type(const symbol_table_t* table, const char* name) {
  const symbol_entry_t* entry = symbol_table_lookup(table, name);
  
  if (entry == NULL || entry->kind != SYMBOL_TYPE) {
    return NULL;
  }
  
  return entry->type_def;
}

/**
 * @brief Lookup a constant by name
 * 
 * @param table Symbol table
 * @param name Constant name
 * @return Constant or NULL if not found
 */
ast_constant_t* symbol_table_lookup_constant(const symbol_table_t* table, const char* name) {
  const symbol_entry_t* entry = symbol_table_lookup(table, name);
  
  if (entry == NULL || entry->kind != SYMBOL_CONSTANT) {
    return NULL;
  }
  
  return entry->constant;
}

/**
 * @brief Lookup a global variable by name
 * 
 * @param table Symbol table
 * @param name Global name
 * @return Global variable or NULL if not found
 */
ast_global_t* symbol_table_lookup_global(const symbol_table_t* table, const char* name) {
  const symbol_entry_t* entry = symbol_table_lookup(table, name);
  
  if (entry == NULL || entry->kind != SYMBOL_GLOBAL) {
    return NULL;
  }
  
  return entry->global;
}

/**
 * @brief Lookup a function by name
 * 
 * @param table Symbol table
 * @param name Function name
 * @return Function or NULL if not found
 */
ast_function_t* symbol_table_lookup_function(const symbol_table_t* table, const char* name) {
  const symbol_entry_t* entry = symbol_table_lookup(table, name);
  
  if (entry == NULL || entry->kind != SYMBOL_FUNCTION) {
    return NULL;
  }
  
  return entry->function;
}

/**
 * @brief Lookup a local variable or parameter by name
 * 
 * @param table Symbol table
 * @param name Variable name
 * @return Operand or NULL if not found
 */
ast_operand_t* symbol_table_lookup_variable(const symbol_table_t* table, const char* name) {
  const symbol_entry_t* entry = symbol_table_lookup(table, name);
  
  if (entry == NULL) {
    return NULL;
  }
  
  if (entry->kind == SYMBOL_LOCAL) {
    return entry->local;
  } else if (entry->kind == SYMBOL_PARAMETER) {
    // Convert parameter to a local variable operand
    // This would normally create a new operand, but for simplicity in this example,
    // we'll just return NULL
    return NULL;
  }
  
  return NULL;
}

/**
 * @brief Lookup a basic block by name
 * 
 * @param table Symbol table
 * @param name Block name
 * @return Basic block or NULL if not found
 */
ast_basic_block_t* symbol_table_lookup_block(const symbol_table_t* table, const char* name) {
  const symbol_entry_t* entry = symbol_table_lookup(table, name);
  
  if (entry == NULL || entry->kind != SYMBOL_BLOCK) {
    return NULL;
  }
  
  return entry->block;
}