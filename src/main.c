/**
 * @file main.c
 * @brief Main entry point for the HOIL to COIL compiler
 * 
 * This file contains the main entry point for the HOIL to COIL compiler.
 * It handles command-line arguments, file I/O, and orchestrates the
 * compilation process.
 *
 * @author Generated by Claude
 * @date 2025-03-13
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "lexer.h"
#include "parser.h"
#include "coil_binary.h"
#include "error_handling.h"

/**
 * @brief Print usage information
 * 
 * @param program_name Name of the executable
 */
static void print_usage(const char* program_name) {
  fprintf(stderr, "Usage: %s [options] input_file [output_file]\n", program_name);
  fprintf(stderr, "Options:\n");
  fprintf(stderr, "  -h, --help        Display this help message\n");
  fprintf(stderr, "  -v, --verbose     Enable verbose output\n");
  fprintf(stderr, "  -d, --debug       Enable debug information\n");
  fprintf(stderr, "  -o <file>         Specify output file\n");
}

/**
 * @brief Command-line options structure
 */
typedef struct {
  bool verbose;
  bool debug;
  char* input_file;
  char* output_file;
} options_t;

/**
 * @brief Parse command-line arguments
 * 
 * @param argc Argument count
 * @param argv Argument values
 * @param opts Options structure to populate
 * @return true if parsing was successful, false otherwise
 */
static bool parse_args(int argc, char** argv, options_t* opts) {
  if (argc < 2) {
    return false;
  }

  // Initialize options with defaults
  opts->verbose = false;
  opts->debug = false;
  opts->input_file = NULL;
  opts->output_file = NULL;

  // Parse arguments
  for (int i = 1; i < argc; i++) {
    if (strcmp(argv[i], "-h") == 0 || strcmp(argv[i], "--help") == 0) {
      return false; // Will display help
    } else if (strcmp(argv[i], "-v") == 0 || strcmp(argv[i], "--verbose") == 0) {
      opts->verbose = true;
    } else if (strcmp(argv[i], "-d") == 0 || strcmp(argv[i], "--debug") == 0) {
      opts->debug = true;
    } else if (strcmp(argv[i], "-o") == 0) {
      if (i + 1 < argc) {
        opts->output_file = argv[++i];
      } else {
        fprintf(stderr, "Error: -o option requires an argument\n");
        return false;
      }
    } else if (opts->input_file == NULL) {
      opts->input_file = argv[i];
    } else if (opts->output_file == NULL) {
      opts->output_file = argv[i];
    } else {
      fprintf(stderr, "Error: Unexpected argument: %s\n", argv[i]);
      return false;
    }
  }

  // Validate required arguments
  if (opts->input_file == NULL) {
    fprintf(stderr, "Error: No input file specified\n");
    return false;
  }

  // If output file not specified, derive from input file
  if (opts->output_file == NULL) {
    size_t input_len = strlen(opts->input_file);
    opts->output_file = malloc(input_len + 2); // +2 for potential extra char and null terminator
    if (opts->output_file == NULL) {
      fprintf(stderr, "Error: Memory allocation failed\n");
      return false;
    }
    
    strncpy(opts->output_file, opts->input_file, input_len + 1);
    
    // Replace extension or append .coil
    char* ext = strrchr(opts->output_file, '.');
    if (ext != NULL) {
      strcpy(ext, ".coil");
    } else {
      strcat(opts->output_file, ".coil");
    }
  }

  return true;
}

/**
 * @brief Read entire file into memory
 * 
 * @param filename File to read
 * @param buffer Pointer to buffer that will be allocated
 * @param size Pointer to store the size of the read file
 * @return true if successful, false otherwise
 */
static bool read_file(const char* filename, char** buffer, size_t* size) {
  FILE* file = fopen(filename, "rb");
  if (file == NULL) {
    fprintf(stderr, "Error: Cannot open file %s\n", filename);
    return false;
  }

  // Get file size
  fseek(file, 0, SEEK_END);
  *size = ftell(file);
  fseek(file, 0, SEEK_SET);

  // Allocate buffer
  *buffer = (char*)malloc(*size + 1); // +1 for null terminator
  if (*buffer == NULL) {
    fprintf(stderr, "Error: Memory allocation failed\n");
    fclose(file);
    return false;
  }

  // Read file content
  size_t read_size = fread(*buffer, 1, *size, file);
  if (read_size != *size) {
    fprintf(stderr, "Error: Failed to read file %s\n", filename);
    free(*buffer);
    fclose(file);
    return false;
  }

  // Add null terminator
  (*buffer)[*size] = '\0';

  fclose(file);
  return true;
}

/**
 * @brief Write binary data to file
 * 
 * @param filename File to write
 * @param data Data to write
 * @param size Size of data in bytes
 * @return true if successful, false otherwise
 */
static bool write_file(const char* filename, const void* data, size_t size) {
  FILE* file = fopen(filename, "wb");
  if (file == NULL) {
    fprintf(stderr, "Error: Cannot open file %s for writing\n", filename);
    return false;
  }

  size_t written = fwrite(data, 1, size, file);
  if (written != size) {
    fprintf(stderr, "Error: Failed to write to file %s\n", filename);
    fclose(file);
    return false;
  }

  fclose(file);
  return true;
}

/**
 * @brief Main function
 * 
 * @param argc Argument count
 * @param argv Argument values
 * @return int Exit code (0 for success, non-zero for error)
 */
int main(int argc, char** argv) {
  options_t opts;
  
  // Parse command-line arguments
  if (!parse_args(argc, argv, &opts)) {
    print_usage(argv[0]);
    return EXIT_FAILURE;
  }

  // Initialize error handling
  error_init(opts.verbose, opts.debug);

  if (opts.verbose) {
    printf("Input file: %s\n", opts.input_file);
    printf("Output file: %s\n", opts.output_file);
  }

  // Read input file
  char* source = NULL;
  size_t source_size = 0;
  if (!read_file(opts.input_file, &source, &source_size)) {
    return EXIT_FAILURE;
  }

  if (opts.verbose) {
    printf("Read %zu bytes from %s\n", source_size, opts.input_file);
  }

  // Initialize lexer
  lexer_t* lexer = lexer_create(source, source_size, opts.input_file);
  if (lexer == NULL) {
    fprintf(stderr, "Error: Failed to initialize lexer\n");
    free(source);
    return EXIT_FAILURE;
  }

  // Initialize parser
  parser_t* parser = parser_create(lexer);
  if (parser == NULL) {
    fprintf(stderr, "Error: Failed to initialize parser\n");
    lexer_destroy(lexer);
    free(source);
    return EXIT_FAILURE;
  }

  // Parse the input file
  ast_module_t* module = parser_parse_module(parser);
  if (module == NULL) {
    fprintf(stderr, "Error: Parsing failed\n");
    parser_destroy(parser);
    lexer_destroy(lexer);
    free(source);
    return EXIT_FAILURE;
  }

  if (opts.verbose) {
    printf("Successfully parsed module: %s\n", module->name);
  }

  // Generate COIL binary
  coil_binary_t* binary = coil_binary_generate(module);
  if (binary == NULL) {
    fprintf(stderr, "Error: COIL binary generation failed\n");
    ast_module_destroy(module);
    parser_destroy(parser);
    lexer_destroy(lexer);
    free(source);
    return EXIT_FAILURE;
  }

  if (opts.verbose) {
    printf("Generated COIL binary, size: %zu bytes\n", binary->size);
  }

  // Write output file
  if (!write_file(opts.output_file, binary->data, binary->size)) {
    coil_binary_destroy(binary);
    ast_module_destroy(module);
    parser_destroy(parser);
    lexer_destroy(lexer);
    free(source);
    return EXIT_FAILURE;
  }

  if (opts.verbose) {
    printf("Successfully wrote COIL binary to %s\n", opts.output_file);
  }

  // Clean up
  coil_binary_destroy(binary);
  ast_module_destroy(module);
  parser_destroy(parser);
  lexer_destroy(lexer);
  
  // Free allocated output filename if it was auto-generated
  if (opts.output_file != NULL && opts.output_file != argv[argc-1]) {
    free(opts.output_file);
  }
  
  free(source);
  
  return EXIT_SUCCESS;
}